"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@popperjs";
exports.ids = ["vendor-chunks/@popperjs"];
exports.modules = {

/***/ "(rsc)/./node_modules/@popperjs/core/dist/cjs/popper.js":
/*!********************************************************!*\
  !*** ./node_modules/@popperjs/core/dist/cjs/popper.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @popperjs/core v2.11.8 - MIT License\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction getWindow(node) {\n    if (node == null) {\n        return window;\n    }\n    if (node.toString() !== \"[object Window]\") {\n        var ownerDocument = node.ownerDocument;\n        return ownerDocument ? ownerDocument.defaultView || window : window;\n    }\n    return node;\n}\nfunction isElement(node) {\n    var OwnElement = getWindow(node).Element;\n    return node instanceof OwnElement || node instanceof Element;\n}\nfunction isHTMLElement(node) {\n    var OwnElement = getWindow(node).HTMLElement;\n    return node instanceof OwnElement || node instanceof HTMLElement;\n}\nfunction isShadowRoot(node) {\n    // IE 11 has no ShadowRoot\n    if (typeof ShadowRoot === \"undefined\") {\n        return false;\n    }\n    var OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nvar max = Math.max;\nvar min = Math.min;\nvar round = Math.round;\nfunction getUAString() {\n    var uaData = navigator.userAgentData;\n    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {\n        return uaData.brands.map(function(item) {\n            return item.brand + \"/\" + item.version;\n        }).join(\" \");\n    }\n    return navigator.userAgent;\n}\nfunction isLayoutViewport() {\n    return !/^((?!chrome|android).)*safari/i.test(getUAString());\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n    if (includeScale === void 0) {\n        includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n        isFixedStrategy = false;\n    }\n    var clientRect = element.getBoundingClientRect();\n    var scaleX = 1;\n    var scaleY = 1;\n    if (includeScale && isHTMLElement(element)) {\n        scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n        scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n    }\n    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;\n    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n    var width = clientRect.width / scaleX;\n    var height = clientRect.height / scaleY;\n    return {\n        width: width,\n        height: height,\n        top: y,\n        right: x + width,\n        bottom: y + height,\n        left: x,\n        x: x,\n        y: y\n    };\n}\nfunction getWindowScroll(node) {\n    var win = getWindow(node);\n    var scrollLeft = win.pageXOffset;\n    var scrollTop = win.pageYOffset;\n    return {\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n    };\n}\nfunction getHTMLElementScroll(element) {\n    return {\n        scrollLeft: element.scrollLeft,\n        scrollTop: element.scrollTop\n    };\n}\nfunction getNodeScroll(node) {\n    if (node === getWindow(node) || !isHTMLElement(node)) {\n        return getWindowScroll(node);\n    } else {\n        return getHTMLElementScroll(node);\n    }\n}\nfunction getNodeName(element) {\n    return element ? (element.nodeName || \"\").toLowerCase() : null;\n}\nfunction getDocumentElement(element) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;\n}\nfunction getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    // Popper 1 is broken in this case and never had a bug report so let's assume\n    // it's not an issue. I don't think anyone ever specifies width on <html>\n    // anyway.\n    // Browsers where the left scrollbar doesn't cause an issue report `0` for\n    // this (e.g. Edge 2019, IE11, Safari)\n    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}\nfunction getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n}\nfunction isScrollParent(element) {\n    // Firefox wants us to check `-x` and `-y` variations as well\n    var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction isElementScaled(element) {\n    var rect = element.getBoundingClientRect();\n    var scaleX = round(rect.width) / element.offsetWidth || 1;\n    var scaleY = round(rect.height) / element.offsetHeight || 1;\n    return scaleX !== 1 || scaleY !== 1;\n} // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n    if (isFixed === void 0) {\n        isFixed = false;\n    }\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n    var documentElement = getDocumentElement(offsetParent);\n    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n    var scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    var offsets = {\n        x: 0,\n        y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n        if (getNodeName(offsetParent) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\n        isScrollParent(documentElement)) {\n            scroll = getNodeScroll(offsetParent);\n        }\n        if (isHTMLElement(offsetParent)) {\n            offsets = getBoundingClientRect(offsetParent, true);\n            offsets.x += offsetParent.clientLeft;\n            offsets.y += offsetParent.clientTop;\n        } else if (documentElement) {\n            offsets.x = getWindowScrollBarX(documentElement);\n        }\n    }\n    return {\n        x: rect.left + scroll.scrollLeft - offsets.x,\n        y: rect.top + scroll.scrollTop - offsets.y,\n        width: rect.width,\n        height: rect.height\n    };\n}\n// means it doesn't take into account transforms.\nfunction getLayoutRect(element) {\n    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n    // Fixes https://github.com/popperjs/popper-core/issues/1223\n    var width = element.offsetWidth;\n    var height = element.offsetHeight;\n    if (Math.abs(clientRect.width - width) <= 1) {\n        width = clientRect.width;\n    }\n    if (Math.abs(clientRect.height - height) <= 1) {\n        height = clientRect.height;\n    }\n    return {\n        x: element.offsetLeft,\n        y: element.offsetTop,\n        width: width,\n        height: height\n    };\n}\nfunction getParentNode(element) {\n    if (getNodeName(element) === \"html\") {\n        return element;\n    }\n    return(// $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n    );\n}\nfunction getScrollParent(node) {\n    if ([\n        \"html\",\n        \"body\",\n        \"#document\"\n    ].indexOf(getNodeName(node)) >= 0) {\n        // $FlowFixMe[incompatible-return]: assume body is always available\n        return node.ownerDocument.body;\n    }\n    if (isHTMLElement(node) && isScrollParent(node)) {\n        return node;\n    }\n    return getScrollParent(getParentNode(node));\n}\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the\nreference element's position.\n*/ function listScrollParents(element, list) {\n    var _element$ownerDocumen;\n    if (list === void 0) {\n        list = [];\n    }\n    var scrollParent = getScrollParent(element);\n    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n    var win = getWindow(scrollParent);\n    var target = isBody ? [\n        win\n    ].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n    var updatedList = list.concat(target);\n    return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));\n}\nfunction isTableElement(element) {\n    return [\n        \"table\",\n        \"td\",\n        \"th\"\n    ].indexOf(getNodeName(element)) >= 0;\n}\nfunction getTrueOffsetParent(element) {\n    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n    getComputedStyle(element).position === \"fixed\") {\n        return null;\n    }\n    return element.offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\nfunction getContainingBlock(element) {\n    var isFirefox = /firefox/i.test(getUAString());\n    var isIE = /Trident/i.test(getUAString());\n    if (isIE && isHTMLElement(element)) {\n        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n        var elementCss = getComputedStyle(element);\n        if (elementCss.position === \"fixed\") {\n            return null;\n        }\n    }\n    var currentNode = getParentNode(element);\n    if (isShadowRoot(currentNode)) {\n        currentNode = currentNode.host;\n    }\n    while(isHTMLElement(currentNode) && [\n        \"html\",\n        \"body\"\n    ].indexOf(getNodeName(currentNode)) < 0){\n        var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n        // create a containing block.\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n        if (css.transform !== \"none\" || css.perspective !== \"none\" || css.contain === \"paint\" || [\n            \"transform\",\n            \"perspective\"\n        ].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === \"filter\" || isFirefox && css.filter && css.filter !== \"none\") {\n            return currentNode;\n        } else {\n            currentNode = currentNode.parentNode;\n        }\n    }\n    return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element) {\n    var window1 = getWindow(element);\n    var offsetParent = getTrueOffsetParent(element);\n    while(offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === \"static\"){\n        offsetParent = getTrueOffsetParent(offsetParent);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === \"html\" || getNodeName(offsetParent) === \"body\" && getComputedStyle(offsetParent).position === \"static\")) {\n        return window1;\n    }\n    return offsetParent || getContainingBlock(element) || window1;\n}\nvar top = \"top\";\nvar bottom = \"bottom\";\nvar right = \"right\";\nvar left = \"left\";\nvar auto = \"auto\";\nvar basePlacements = [\n    top,\n    bottom,\n    right,\n    left\n];\nvar start = \"start\";\nvar end = \"end\";\nvar clippingParents = \"clippingParents\";\nvar viewport = \"viewport\";\nvar popper = \"popper\";\nvar reference = \"reference\";\nvar variationPlacements = /*#__PURE__*/ basePlacements.reduce(function(acc, placement) {\n    return acc.concat([\n        placement + \"-\" + start,\n        placement + \"-\" + end\n    ]);\n}, []);\nvar placements = /*#__PURE__*/ [].concat(basePlacements, [\n    auto\n]).reduce(function(acc, placement) {\n    return acc.concat([\n        placement,\n        placement + \"-\" + start,\n        placement + \"-\" + end\n    ]);\n}, []); // modifiers that need to read the DOM\nvar beforeRead = \"beforeRead\";\nvar read = \"read\";\nvar afterRead = \"afterRead\"; // pure-logic modifiers\nvar beforeMain = \"beforeMain\";\nvar main = \"main\";\nvar afterMain = \"afterMain\"; // modifier with the purpose to write to the DOM (or write into a framework state)\nvar beforeWrite = \"beforeWrite\";\nvar write = \"write\";\nvar afterWrite = \"afterWrite\";\nvar modifierPhases = [\n    beforeRead,\n    read,\n    afterRead,\n    beforeMain,\n    main,\n    afterMain,\n    beforeWrite,\n    write,\n    afterWrite\n];\nfunction order(modifiers) {\n    var map = new Map();\n    var visited = new Set();\n    var result = [];\n    modifiers.forEach(function(modifier) {\n        map.set(modifier.name, modifier);\n    }); // On visiting object, check for its dependencies and visit them recursively\n    function sort(modifier) {\n        visited.add(modifier.name);\n        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n        requires.forEach(function(dep) {\n            if (!visited.has(dep)) {\n                var depModifier = map.get(dep);\n                if (depModifier) {\n                    sort(depModifier);\n                }\n            }\n        });\n        result.push(modifier);\n    }\n    modifiers.forEach(function(modifier) {\n        if (!visited.has(modifier.name)) {\n            // check for visited object\n            sort(modifier);\n        }\n    });\n    return result;\n}\nfunction orderModifiers(modifiers) {\n    // order based on dependencies\n    var orderedModifiers = order(modifiers); // order based on phase\n    return modifierPhases.reduce(function(acc, phase) {\n        return acc.concat(orderedModifiers.filter(function(modifier) {\n            return modifier.phase === phase;\n        }));\n    }, []);\n}\nfunction debounce(fn) {\n    var pending;\n    return function() {\n        if (!pending) {\n            pending = new Promise(function(resolve) {\n                Promise.resolve().then(function() {\n                    pending = undefined;\n                    resolve(fn());\n                });\n            });\n        }\n        return pending;\n    };\n}\nfunction mergeByName(modifiers) {\n    var merged = modifiers.reduce(function(merged, current) {\n        var existing = merged[current.name];\n        merged[current.name] = existing ? Object.assign({}, existing, current, {\n            options: Object.assign({}, existing.options, current.options),\n            data: Object.assign({}, existing.data, current.data)\n        }) : current;\n        return merged;\n    }, {}); // IE11 does not support Object.values\n    return Object.keys(merged).map(function(key) {\n        return merged[key];\n    });\n}\nfunction getViewportRect(element, strategy) {\n    var win = getWindow(element);\n    var html = getDocumentElement(element);\n    var visualViewport = win.visualViewport;\n    var width = html.clientWidth;\n    var height = html.clientHeight;\n    var x = 0;\n    var y = 0;\n    if (visualViewport) {\n        width = visualViewport.width;\n        height = visualViewport.height;\n        var layoutViewport = isLayoutViewport();\n        if (layoutViewport || !layoutViewport && strategy === \"fixed\") {\n            x = visualViewport.offsetLeft;\n            y = visualViewport.offsetTop;\n        }\n    }\n    return {\n        width: width,\n        height: height,\n        x: x + getWindowScrollBarX(element),\n        y: y\n    };\n}\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\nfunction getDocumentRect(element) {\n    var _element$ownerDocumen;\n    var html = getDocumentElement(element);\n    var winScroll = getWindowScroll(element);\n    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n    var y = -winScroll.scrollTop;\n    if (getComputedStyle(body || html).direction === \"rtl\") {\n        x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n    }\n    return {\n        width: width,\n        height: height,\n        x: x,\n        y: y\n    };\n}\nfunction contains(parent, child) {\n    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n    if (parent.contains(child)) {\n        return true;\n    } else if (rootNode && isShadowRoot(rootNode)) {\n        var next = child;\n        do {\n            if (next && parent.isSameNode(next)) {\n                return true;\n            } // $FlowFixMe[prop-missing]: need a better way to handle this...\n            next = next.parentNode || next.host;\n        }while (next);\n    } // Give up, the result is false\n    return false;\n}\nfunction rectToClientRect(rect) {\n    return Object.assign({}, rect, {\n        left: rect.x,\n        top: rect.y,\n        right: rect.x + rect.width,\n        bottom: rect.y + rect.height\n    });\n}\nfunction getInnerBoundingClientRect(element, strategy) {\n    var rect = getBoundingClientRect(element, false, strategy === \"fixed\");\n    rect.top = rect.top + element.clientTop;\n    rect.left = rect.left + element.clientLeft;\n    rect.bottom = rect.top + element.clientHeight;\n    rect.right = rect.left + element.clientWidth;\n    rect.width = element.clientWidth;\n    rect.height = element.clientHeight;\n    rect.x = rect.left;\n    rect.y = rect.top;\n    return rect;\n}\nfunction getClientRectFromMixedType(element, clippingParent, strategy) {\n    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\nfunction getClippingParents(element) {\n    var clippingParents = listScrollParents(getParentNode(element));\n    var canEscapeClipping = [\n        \"absolute\",\n        \"fixed\"\n    ].indexOf(getComputedStyle(element).position) >= 0;\n    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n    if (!isElement(clipperElement)) {\n        return [];\n    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n    return clippingParents.filter(function(clippingParent) {\n        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== \"body\";\n    });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\nfunction getClippingRect(element, boundary, rootBoundary, strategy) {\n    var mainClippingParents = boundary === \"clippingParents\" ? getClippingParents(element) : [].concat(boundary);\n    var clippingParents = [].concat(mainClippingParents, [\n        rootBoundary\n    ]);\n    var firstClippingParent = clippingParents[0];\n    var clippingRect = clippingParents.reduce(function(accRect, clippingParent) {\n        var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n        accRect.top = max(rect.top, accRect.top);\n        accRect.right = min(rect.right, accRect.right);\n        accRect.bottom = min(rect.bottom, accRect.bottom);\n        accRect.left = max(rect.left, accRect.left);\n        return accRect;\n    }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n    clippingRect.width = clippingRect.right - clippingRect.left;\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\n    clippingRect.x = clippingRect.left;\n    clippingRect.y = clippingRect.top;\n    return clippingRect;\n}\nfunction getBasePlacement(placement) {\n    return placement.split(\"-\")[0];\n}\nfunction getVariation(placement) {\n    return placement.split(\"-\")[1];\n}\nfunction getMainAxisFromPlacement(placement) {\n    return [\n        \"top\",\n        \"bottom\"\n    ].indexOf(placement) >= 0 ? \"x\" : \"y\";\n}\nfunction computeOffsets(_ref) {\n    var reference = _ref.reference, element = _ref.element, placement = _ref.placement;\n    var basePlacement = placement ? getBasePlacement(placement) : null;\n    var variation = placement ? getVariation(placement) : null;\n    var commonX = reference.x + reference.width / 2 - element.width / 2;\n    var commonY = reference.y + reference.height / 2 - element.height / 2;\n    var offsets;\n    switch(basePlacement){\n        case top:\n            offsets = {\n                x: commonX,\n                y: reference.y - element.height\n            };\n            break;\n        case bottom:\n            offsets = {\n                x: commonX,\n                y: reference.y + reference.height\n            };\n            break;\n        case right:\n            offsets = {\n                x: reference.x + reference.width,\n                y: commonY\n            };\n            break;\n        case left:\n            offsets = {\n                x: reference.x - element.width,\n                y: commonY\n            };\n            break;\n        default:\n            offsets = {\n                x: reference.x,\n                y: reference.y\n            };\n    }\n    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n    if (mainAxis != null) {\n        var len = mainAxis === \"y\" ? \"height\" : \"width\";\n        switch(variation){\n            case start:\n                offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n                break;\n            case end:\n                offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n                break;\n        }\n    }\n    return offsets;\n}\nfunction getFreshSideObject() {\n    return {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n    };\n}\nfunction mergePaddingObject(paddingObject) {\n    return Object.assign({}, getFreshSideObject(), paddingObject);\n}\nfunction expandToHashMap(value, keys) {\n    return keys.reduce(function(hashMap, key) {\n        hashMap[key] = value;\n        return hashMap;\n    }, {});\n}\nfunction detectOverflow(state, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;\n    var paddingObject = mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n    var altContext = elementContext === popper ? reference : popper;\n    var popperRect = state.rects.popper;\n    var element = state.elements[altBoundary ? altContext : elementContext];\n    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);\n    var referenceClientRect = getBoundingClientRect(state.elements.reference);\n    var popperOffsets = computeOffsets({\n        reference: referenceClientRect,\n        element: popperRect,\n        strategy: \"absolute\",\n        placement: placement\n    });\n    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n    // 0 or negative = within the clipping rect\n    var overflowOffsets = {\n        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n        right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n    if (elementContext === popper && offsetData) {\n        var offset = offsetData[placement];\n        Object.keys(overflowOffsets).forEach(function(key) {\n            var multiply = [\n                right,\n                bottom\n            ].indexOf(key) >= 0 ? 1 : -1;\n            var axis = [\n                top,\n                bottom\n            ].indexOf(key) >= 0 ? \"y\" : \"x\";\n            overflowOffsets[key] += offset[axis] * multiply;\n        });\n    }\n    return overflowOffsets;\n}\nvar DEFAULT_OPTIONS = {\n    placement: \"bottom\",\n    modifiers: [],\n    strategy: \"absolute\"\n};\nfunction areValidElements() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return !args.some(function(element) {\n        return !(element && typeof element.getBoundingClientRect === \"function\");\n    });\n}\nfunction popperGenerator(generatorOptions) {\n    if (generatorOptions === void 0) {\n        generatorOptions = {};\n    }\n    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n    return function createPopper(reference, popper, options) {\n        if (options === void 0) {\n            options = defaultOptions;\n        }\n        var state = {\n            placement: \"bottom\",\n            orderedModifiers: [],\n            options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n            modifiersData: {},\n            elements: {\n                reference: reference,\n                popper: popper\n            },\n            attributes: {},\n            styles: {}\n        };\n        var effectCleanupFns = [];\n        var isDestroyed = false;\n        var instance = {\n            state: state,\n            setOptions: function setOptions(setOptionsAction) {\n                var options = typeof setOptionsAction === \"function\" ? setOptionsAction(state.options) : setOptionsAction;\n                cleanupModifierEffects();\n                state.options = Object.assign({}, defaultOptions, state.options, options);\n                state.scrollParents = {\n                    reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n                    popper: listScrollParents(popper)\n                }; // Orders the modifiers based on their dependencies and `phase`\n                // properties\n                var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n                state.orderedModifiers = orderedModifiers.filter(function(m) {\n                    return m.enabled;\n                });\n                runModifierEffects();\n                return instance.update();\n            },\n            // Sync update – it will always be executed, even if not necessary. This\n            // is useful for low frequency updates where sync behavior simplifies the\n            // logic.\n            // For high frequency updates (e.g. `resize` and `scroll` events), always\n            // prefer the async Popper#update method\n            forceUpdate: function forceUpdate() {\n                if (isDestroyed) {\n                    return;\n                }\n                var _state$elements = state.elements, reference = _state$elements.reference, popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n                // anymore\n                if (!areValidElements(reference, popper)) {\n                    return;\n                } // Store the reference and popper rects to be read by modifiers\n                state.rects = {\n                    reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === \"fixed\"),\n                    popper: getLayoutRect(popper)\n                }; // Modifiers have the ability to reset the current update cycle. The\n                // most common use case for this is the `flip` modifier changing the\n                // placement, which then needs to re-run all the modifiers, because the\n                // logic was previously ran for the previous placement and is therefore\n                // stale/incorrect\n                state.reset = false;\n                state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n                // is filled with the initial data specified by the modifier. This means\n                // it doesn't persist and is fresh on each update.\n                // To ensure persistent data, use `${name}#persistent`\n                state.orderedModifiers.forEach(function(modifier) {\n                    return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n                });\n                for(var index = 0; index < state.orderedModifiers.length; index++){\n                    if (state.reset === true) {\n                        state.reset = false;\n                        index = -1;\n                        continue;\n                    }\n                    var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;\n                    if (typeof fn === \"function\") {\n                        state = fn({\n                            state: state,\n                            options: _options,\n                            name: name,\n                            instance: instance\n                        }) || state;\n                    }\n                }\n            },\n            // Async and optimistically optimized update – it will not be executed if\n            // not necessary (debounced to run at most once-per-tick)\n            update: debounce(function() {\n                return new Promise(function(resolve) {\n                    instance.forceUpdate();\n                    resolve(state);\n                });\n            }),\n            destroy: function destroy() {\n                cleanupModifierEffects();\n                isDestroyed = true;\n            }\n        };\n        if (!areValidElements(reference, popper)) {\n            return instance;\n        }\n        instance.setOptions(options).then(function(state) {\n            if (!isDestroyed && options.onFirstUpdate) {\n                options.onFirstUpdate(state);\n            }\n        }); // Modifiers have the ability to execute arbitrary code before the first\n        // update cycle runs. They will be executed in the same order as the update\n        // cycle. This is useful when a modifier adds some persistent data that\n        // other modifiers need to use, but the modifier is run after the dependent\n        // one.\n        function runModifierEffects() {\n            state.orderedModifiers.forEach(function(_ref) {\n                var name = _ref.name, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, effect = _ref.effect;\n                if (typeof effect === \"function\") {\n                    var cleanupFn = effect({\n                        state: state,\n                        name: name,\n                        instance: instance,\n                        options: options\n                    });\n                    var noopFn = function noopFn() {};\n                    effectCleanupFns.push(cleanupFn || noopFn);\n                }\n            });\n        }\n        function cleanupModifierEffects() {\n            effectCleanupFns.forEach(function(fn) {\n                return fn();\n            });\n            effectCleanupFns = [];\n        }\n        return instance;\n    };\n}\nvar passive = {\n    passive: true\n};\nfunction effect$2(_ref) {\n    var state = _ref.state, instance = _ref.instance, options = _ref.options;\n    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;\n    var window1 = getWindow(state.elements.popper);\n    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n    if (scroll) {\n        scrollParents.forEach(function(scrollParent) {\n            scrollParent.addEventListener(\"scroll\", instance.update, passive);\n        });\n    }\n    if (resize) {\n        window1.addEventListener(\"resize\", instance.update, passive);\n    }\n    return function() {\n        if (scroll) {\n            scrollParents.forEach(function(scrollParent) {\n                scrollParent.removeEventListener(\"scroll\", instance.update, passive);\n            });\n        }\n        if (resize) {\n            window1.removeEventListener(\"resize\", instance.update, passive);\n        }\n    };\n} // eslint-disable-next-line import/no-unused-modules\nvar eventListeners = {\n    name: \"eventListeners\",\n    enabled: true,\n    phase: \"write\",\n    fn: function fn() {},\n    effect: effect$2,\n    data: {}\n};\nfunction popperOffsets(_ref) {\n    var state = _ref.state, name = _ref.name;\n    // Offsets are the actual position the popper needs to have to be\n    // properly positioned near its reference element\n    // This is the most basic placement, and will be adjusted by\n    // the modifiers in the next step\n    state.modifiersData[name] = computeOffsets({\n        reference: state.rects.reference,\n        element: state.rects.popper,\n        strategy: \"absolute\",\n        placement: state.placement\n    });\n} // eslint-disable-next-line import/no-unused-modules\nvar popperOffsets$1 = {\n    name: \"popperOffsets\",\n    enabled: true,\n    phase: \"read\",\n    fn: popperOffsets,\n    data: {}\n};\nvar unsetSides = {\n    top: \"auto\",\n    right: \"auto\",\n    bottom: \"auto\",\n    left: \"auto\"\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\nfunction roundOffsetsByDPR(_ref, win) {\n    var x = _ref.x, y = _ref.y;\n    var dpr = win.devicePixelRatio || 1;\n    return {\n        x: round(x * dpr) / dpr || 0,\n        y: round(y * dpr) / dpr || 0\n    };\n}\nfunction mapToStyles(_ref2) {\n    var _Object$assign2;\n    var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;\n    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;\n    var _ref3 = typeof roundOffsets === \"function\" ? roundOffsets({\n        x: x,\n        y: y\n    }) : {\n        x: x,\n        y: y\n    };\n    x = _ref3.x;\n    y = _ref3.y;\n    var hasX = offsets.hasOwnProperty(\"x\");\n    var hasY = offsets.hasOwnProperty(\"y\");\n    var sideX = left;\n    var sideY = top;\n    var win = window;\n    if (adaptive) {\n        var offsetParent = getOffsetParent(popper);\n        var heightProp = \"clientHeight\";\n        var widthProp = \"clientWidth\";\n        if (offsetParent === getWindow(popper)) {\n            offsetParent = getDocumentElement(popper);\n            if (getComputedStyle(offsetParent).position !== \"static\" && position === \"absolute\") {\n                heightProp = \"scrollHeight\";\n                widthProp = \"scrollWidth\";\n            }\n        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n        offsetParent = offsetParent;\n        if (placement === top || (placement === left || placement === right) && variation === end) {\n            sideY = bottom;\n            var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];\n            y -= offsetY - popperRect.height;\n            y *= gpuAcceleration ? 1 : -1;\n        }\n        if (placement === left || (placement === top || placement === bottom) && variation === end) {\n            sideX = right;\n            var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];\n            x -= offsetX - popperRect.width;\n            x *= gpuAcceleration ? 1 : -1;\n        }\n    }\n    var commonStyles = Object.assign({\n        position: position\n    }, adaptive && unsetSides);\n    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n        x: x,\n        y: y\n    }, getWindow(popper)) : {\n        x: x,\n        y: y\n    };\n    x = _ref4.x;\n    y = _ref4.y;\n    if (gpuAcceleration) {\n        var _Object$assign;\n        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? \"0\" : \"\", _Object$assign[sideX] = hasX ? \"0\" : \"\", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n    }\n    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : \"\", _Object$assign2[sideX] = hasX ? x + \"px\" : \"\", _Object$assign2.transform = \"\", _Object$assign2));\n}\nfunction computeStyles(_ref5) {\n    var state = _ref5.state, options = _ref5.options;\n    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n    var commonStyles = {\n        placement: getBasePlacement(state.placement),\n        variation: getVariation(state.placement),\n        popper: state.elements.popper,\n        popperRect: state.rects.popper,\n        gpuAcceleration: gpuAcceleration,\n        isFixed: state.options.strategy === \"fixed\"\n    };\n    if (state.modifiersData.popperOffsets != null) {\n        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n            offsets: state.modifiersData.popperOffsets,\n            position: state.options.strategy,\n            adaptive: adaptive,\n            roundOffsets: roundOffsets\n        })));\n    }\n    if (state.modifiersData.arrow != null) {\n        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n            offsets: state.modifiersData.arrow,\n            position: \"absolute\",\n            adaptive: false,\n            roundOffsets: roundOffsets\n        })));\n    }\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n        \"data-popper-placement\": state.placement\n    });\n} // eslint-disable-next-line import/no-unused-modules\nvar computeStyles$1 = {\n    name: \"computeStyles\",\n    enabled: true,\n    phase: \"beforeWrite\",\n    fn: computeStyles,\n    data: {}\n};\n// and applies them to the HTMLElements such as popper and arrow\nfunction applyStyles(_ref) {\n    var state = _ref.state;\n    Object.keys(state.elements).forEach(function(name) {\n        var style = state.styles[name] || {};\n        var attributes = state.attributes[name] || {};\n        var element = state.elements[name]; // arrow is optional + virtual elements\n        if (!isHTMLElement(element) || !getNodeName(element)) {\n            return;\n        } // Flow doesn't support to extend this property, but it's the most\n        // effective way to apply styles to an HTMLElement\n        // $FlowFixMe[cannot-write]\n        Object.assign(element.style, style);\n        Object.keys(attributes).forEach(function(name) {\n            var value = attributes[name];\n            if (value === false) {\n                element.removeAttribute(name);\n            } else {\n                element.setAttribute(name, value === true ? \"\" : value);\n            }\n        });\n    });\n}\nfunction effect$1(_ref2) {\n    var state = _ref2.state;\n    var initialStyles = {\n        popper: {\n            position: state.options.strategy,\n            left: \"0\",\n            top: \"0\",\n            margin: \"0\"\n        },\n        arrow: {\n            position: \"absolute\"\n        },\n        reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n    if (state.elements.arrow) {\n        Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    }\n    return function() {\n        Object.keys(state.elements).forEach(function(name) {\n            var element = state.elements[name];\n            var attributes = state.attributes[name] || {};\n            var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n            var style = styleProperties.reduce(function(style, property) {\n                style[property] = \"\";\n                return style;\n            }, {}); // arrow is optional + virtual elements\n            if (!isHTMLElement(element) || !getNodeName(element)) {\n                return;\n            }\n            Object.assign(element.style, style);\n            Object.keys(attributes).forEach(function(attribute) {\n                element.removeAttribute(attribute);\n            });\n        });\n    };\n} // eslint-disable-next-line import/no-unused-modules\nvar applyStyles$1 = {\n    name: \"applyStyles\",\n    enabled: true,\n    phase: \"write\",\n    fn: applyStyles,\n    effect: effect$1,\n    requires: [\n        \"computeStyles\"\n    ]\n};\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\n    var basePlacement = getBasePlacement(placement);\n    var invertDistance = [\n        left,\n        top\n    ].indexOf(basePlacement) >= 0 ? -1 : 1;\n    var _ref = typeof offset === \"function\" ? offset(Object.assign({}, rects, {\n        placement: placement\n    })) : offset, skidding = _ref[0], distance = _ref[1];\n    skidding = skidding || 0;\n    distance = (distance || 0) * invertDistance;\n    return [\n        left,\n        right\n    ].indexOf(basePlacement) >= 0 ? {\n        x: distance,\n        y: skidding\n    } : {\n        x: skidding,\n        y: distance\n    };\n}\nfunction offset(_ref2) {\n    var state = _ref2.state, options = _ref2.options, name = _ref2.name;\n    var _options$offset = options.offset, offset = _options$offset === void 0 ? [\n        0,\n        0\n    ] : _options$offset;\n    var data = placements.reduce(function(acc, placement) {\n        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n        return acc;\n    }, {});\n    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;\n    if (state.modifiersData.popperOffsets != null) {\n        state.modifiersData.popperOffsets.x += x;\n        state.modifiersData.popperOffsets.y += y;\n    }\n    state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\nvar offset$1 = {\n    name: \"offset\",\n    enabled: true,\n    phase: \"main\",\n    requires: [\n        \"popperOffsets\"\n    ],\n    fn: offset\n};\nvar hash$1 = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n};\nfunction getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, function(matched) {\n        return hash$1[matched];\n    });\n}\nvar hash = {\n    start: \"end\",\n    end: \"start\"\n};\nfunction getOppositeVariationPlacement(placement) {\n    return placement.replace(/start|end/g, function(matched) {\n        return hash[matched];\n    });\n}\nfunction computeAutoPlacement(state, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n    var variation = getVariation(placement);\n    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement) {\n        return getVariation(placement) === variation;\n    }) : basePlacements;\n    var allowedPlacements = placements$1.filter(function(placement) {\n        return allowedAutoPlacements.indexOf(placement) >= 0;\n    });\n    if (allowedPlacements.length === 0) {\n        allowedPlacements = placements$1;\n    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n    var overflows = allowedPlacements.reduce(function(acc, placement) {\n        acc[placement] = detectOverflow(state, {\n            placement: placement,\n            boundary: boundary,\n            rootBoundary: rootBoundary,\n            padding: padding\n        })[getBasePlacement(placement)];\n        return acc;\n    }, {});\n    return Object.keys(overflows).sort(function(a, b) {\n        return overflows[a] - overflows[b];\n    });\n}\nfunction getExpandedFallbackPlacements(placement) {\n    if (getBasePlacement(placement) === auto) {\n        return [];\n    }\n    var oppositePlacement = getOppositePlacement(placement);\n    return [\n        getOppositeVariationPlacement(placement),\n        oppositePlacement,\n        getOppositeVariationPlacement(oppositePlacement)\n    ];\n}\nfunction flip(_ref) {\n    var state = _ref.state, options = _ref.options, name = _ref.name;\n    if (state.modifiersData[name]._skip) {\n        return;\n    }\n    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;\n    var preferredPlacement = state.options.placement;\n    var basePlacement = getBasePlacement(preferredPlacement);\n    var isBasePlacement = basePlacement === preferredPlacement;\n    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [\n        getOppositePlacement(preferredPlacement)\n    ] : getExpandedFallbackPlacements(preferredPlacement));\n    var placements = [\n        preferredPlacement\n    ].concat(fallbackPlacements).reduce(function(acc, placement) {\n        return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n            placement: placement,\n            boundary: boundary,\n            rootBoundary: rootBoundary,\n            padding: padding,\n            flipVariations: flipVariations,\n            allowedAutoPlacements: allowedAutoPlacements\n        }) : placement);\n    }, []);\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var checksMap = new Map();\n    var makeFallbackChecks = true;\n    var firstFittingPlacement = placements[0];\n    for(var i = 0; i < placements.length; i++){\n        var placement = placements[i];\n        var _basePlacement = getBasePlacement(placement);\n        var isStartVariation = getVariation(placement) === start;\n        var isVertical = [\n            top,\n            bottom\n        ].indexOf(_basePlacement) >= 0;\n        var len = isVertical ? \"width\" : \"height\";\n        var overflow = detectOverflow(state, {\n            placement: placement,\n            boundary: boundary,\n            rootBoundary: rootBoundary,\n            altBoundary: altBoundary,\n            padding: padding\n        });\n        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n        if (referenceRect[len] > popperRect[len]) {\n            mainVariationSide = getOppositePlacement(mainVariationSide);\n        }\n        var altVariationSide = getOppositePlacement(mainVariationSide);\n        var checks = [];\n        if (checkMainAxis) {\n            checks.push(overflow[_basePlacement] <= 0);\n        }\n        if (checkAltAxis) {\n            checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n        }\n        if (checks.every(function(check) {\n            return check;\n        })) {\n            firstFittingPlacement = placement;\n            makeFallbackChecks = false;\n            break;\n        }\n        checksMap.set(placement, checks);\n    }\n    if (makeFallbackChecks) {\n        // `2` may be desired in some cases – research later\n        var numberOfChecks = flipVariations ? 3 : 1;\n        var _loop = function _loop(_i) {\n            var fittingPlacement = placements.find(function(placement) {\n                var checks = checksMap.get(placement);\n                if (checks) {\n                    return checks.slice(0, _i).every(function(check) {\n                        return check;\n                    });\n                }\n            });\n            if (fittingPlacement) {\n                firstFittingPlacement = fittingPlacement;\n                return \"break\";\n            }\n        };\n        for(var _i = numberOfChecks; _i > 0; _i--){\n            var _ret = _loop(_i);\n            if (_ret === \"break\") break;\n        }\n    }\n    if (state.placement !== firstFittingPlacement) {\n        state.modifiersData[name]._skip = true;\n        state.placement = firstFittingPlacement;\n        state.reset = true;\n    }\n} // eslint-disable-next-line import/no-unused-modules\nvar flip$1 = {\n    name: \"flip\",\n    enabled: true,\n    phase: \"main\",\n    fn: flip,\n    requiresIfExists: [\n        \"offset\"\n    ],\n    data: {\n        _skip: false\n    }\n};\nfunction getAltAxis(axis) {\n    return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction within(min$1, value, max$1) {\n    return max(min$1, min(value, max$1));\n}\nfunction withinMaxClamp(min, value, max) {\n    var v = within(min, value, max);\n    return v > max ? max : v;\n}\nfunction preventOverflow(_ref) {\n    var state = _ref.state, options = _ref.options, name = _ref.name;\n    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n    var overflow = detectOverflow(state, {\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding,\n        altBoundary: altBoundary\n    });\n    var basePlacement = getBasePlacement(state.placement);\n    var variation = getVariation(state.placement);\n    var isBasePlacement = !variation;\n    var mainAxis = getMainAxisFromPlacement(basePlacement);\n    var altAxis = getAltAxis(mainAxis);\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var tetherOffsetValue = typeof tetherOffset === \"function\" ? tetherOffset(Object.assign({}, state.rects, {\n        placement: state.placement\n    })) : tetherOffset;\n    var normalizedTetherOffsetValue = typeof tetherOffsetValue === \"number\" ? {\n        mainAxis: tetherOffsetValue,\n        altAxis: tetherOffsetValue\n    } : Object.assign({\n        mainAxis: 0,\n        altAxis: 0\n    }, tetherOffsetValue);\n    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n    var data = {\n        x: 0,\n        y: 0\n    };\n    if (!popperOffsets) {\n        return;\n    }\n    if (checkMainAxis) {\n        var _offsetModifierState$;\n        var mainSide = mainAxis === \"y\" ? top : left;\n        var altSide = mainAxis === \"y\" ? bottom : right;\n        var len = mainAxis === \"y\" ? \"height\" : \"width\";\n        var offset = popperOffsets[mainAxis];\n        var min$1 = offset + overflow[mainSide];\n        var max$1 = offset - overflow[altSide];\n        var additive = tether ? -popperRect[len] / 2 : 0;\n        var minLen = variation === start ? referenceRect[len] : popperRect[len];\n        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n        // outside the reference bounds\n        var arrowElement = state.elements.arrow;\n        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n            width: 0,\n            height: 0\n        };\n        var arrowPaddingObject = state.modifiersData[\"arrow#persistent\"] ? state.modifiersData[\"arrow#persistent\"].padding : getFreshSideObject();\n        var arrowPaddingMin = arrowPaddingObject[mainSide];\n        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n        // to include its full size in the calculation. If the reference is small\n        // and near the edge of a boundary, the popper can overflow even if the\n        // reference is not overflowing as well (e.g. virtual elements with no\n        // width or height)\n        var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n        var clientOffset = arrowOffsetParent ? mainAxis === \"y\" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n        var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n        var tetherMax = offset + maxOffset - offsetModifierValue;\n        var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\n        popperOffsets[mainAxis] = preventedOffset;\n        data[mainAxis] = preventedOffset - offset;\n    }\n    if (checkAltAxis) {\n        var _offsetModifierState$2;\n        var _mainSide = mainAxis === \"x\" ? top : left;\n        var _altSide = mainAxis === \"x\" ? bottom : right;\n        var _offset = popperOffsets[altAxis];\n        var _len = altAxis === \"y\" ? \"height\" : \"width\";\n        var _min = _offset + overflow[_mainSide];\n        var _max = _offset - overflow[_altSide];\n        var isOriginSide = [\n            top,\n            left\n        ].indexOf(basePlacement) !== -1;\n        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n        popperOffsets[altAxis] = _preventedOffset;\n        data[altAxis] = _preventedOffset - _offset;\n    }\n    state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\nvar preventOverflow$1 = {\n    name: \"preventOverflow\",\n    enabled: true,\n    phase: \"main\",\n    fn: preventOverflow,\n    requiresIfExists: [\n        \"offset\"\n    ]\n};\nvar toPaddingObject = function toPaddingObject(padding, state) {\n    padding = typeof padding === \"function\" ? padding(Object.assign({}, state.rects, {\n        placement: state.placement\n    })) : padding;\n    return mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n};\nfunction arrow(_ref) {\n    var _state$modifiersData$;\n    var state = _ref.state, name = _ref.name, options = _ref.options;\n    var arrowElement = state.elements.arrow;\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var basePlacement = getBasePlacement(state.placement);\n    var axis = getMainAxisFromPlacement(basePlacement);\n    var isVertical = [\n        left,\n        right\n    ].indexOf(basePlacement) >= 0;\n    var len = isVertical ? \"height\" : \"width\";\n    if (!arrowElement || !popperOffsets) {\n        return;\n    }\n    var paddingObject = toPaddingObject(options.padding, state);\n    var arrowRect = getLayoutRect(arrowElement);\n    var minProp = axis === \"y\" ? top : left;\n    var maxProp = axis === \"y\" ? bottom : right;\n    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n    var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n    var arrowOffsetParent = getOffsetParent(arrowElement);\n    var clientSize = arrowOffsetParent ? axis === \"y\" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n    // outside of the popper bounds\n    var min = paddingObject[minProp];\n    var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n    var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n    var axisProp = axis;\n    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\nfunction effect(_ref2) {\n    var state = _ref2.state, options = _ref2.options;\n    var _options$element = options.element, arrowElement = _options$element === void 0 ? \"[data-popper-arrow]\" : _options$element;\n    if (arrowElement == null) {\n        return;\n    } // CSS selector\n    if (typeof arrowElement === \"string\") {\n        arrowElement = state.elements.popper.querySelector(arrowElement);\n        if (!arrowElement) {\n            return;\n        }\n    }\n    if (!contains(state.elements.popper, arrowElement)) {\n        return;\n    }\n    state.elements.arrow = arrowElement;\n} // eslint-disable-next-line import/no-unused-modules\nvar arrow$1 = {\n    name: \"arrow\",\n    enabled: true,\n    phase: \"main\",\n    fn: arrow,\n    effect: effect,\n    requires: [\n        \"popperOffsets\"\n    ],\n    requiresIfExists: [\n        \"preventOverflow\"\n    ]\n};\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n    if (preventedOffsets === void 0) {\n        preventedOffsets = {\n            x: 0,\n            y: 0\n        };\n    }\n    return {\n        top: overflow.top - rect.height - preventedOffsets.y,\n        right: overflow.right - rect.width + preventedOffsets.x,\n        bottom: overflow.bottom - rect.height + preventedOffsets.y,\n        left: overflow.left - rect.width - preventedOffsets.x\n    };\n}\nfunction isAnySideFullyClipped(overflow) {\n    return [\n        top,\n        right,\n        bottom,\n        left\n    ].some(function(side) {\n        return overflow[side] >= 0;\n    });\n}\nfunction hide(_ref) {\n    var state = _ref.state, name = _ref.name;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var preventedOffsets = state.modifiersData.preventOverflow;\n    var referenceOverflow = detectOverflow(state, {\n        elementContext: \"reference\"\n    });\n    var popperAltOverflow = detectOverflow(state, {\n        altBoundary: true\n    });\n    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n    state.modifiersData[name] = {\n        referenceClippingOffsets: referenceClippingOffsets,\n        popperEscapeOffsets: popperEscapeOffsets,\n        isReferenceHidden: isReferenceHidden,\n        hasPopperEscaped: hasPopperEscaped\n    };\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n        \"data-popper-reference-hidden\": isReferenceHidden,\n        \"data-popper-escaped\": hasPopperEscaped\n    });\n} // eslint-disable-next-line import/no-unused-modules\nvar hide$1 = {\n    name: \"hide\",\n    enabled: true,\n    phase: \"main\",\n    requiresIfExists: [\n        \"preventOverflow\"\n    ],\n    fn: hide\n};\nvar defaultModifiers$1 = [\n    eventListeners,\n    popperOffsets$1,\n    computeStyles$1,\n    applyStyles$1\n];\nvar createPopper$1 = /*#__PURE__*/ popperGenerator({\n    defaultModifiers: defaultModifiers$1\n}); // eslint-disable-next-line import/no-unused-modules\nvar defaultModifiers = [\n    eventListeners,\n    popperOffsets$1,\n    computeStyles$1,\n    applyStyles$1,\n    offset$1,\n    flip$1,\n    preventOverflow$1,\n    arrow$1,\n    hide$1\n];\nvar createPopper = /*#__PURE__*/ popperGenerator({\n    defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\nexports.applyStyles = applyStyles$1;\nexports.arrow = arrow$1;\nexports.computeStyles = computeStyles$1;\nexports.createPopper = createPopper;\nexports.createPopperLite = createPopper$1;\nexports.defaultModifiers = defaultModifiers;\nexports.detectOverflow = detectOverflow;\nexports.eventListeners = eventListeners;\nexports.flip = flip$1;\nexports.hide = hide$1;\nexports.offset = offset$1;\nexports.popperGenerator = popperGenerator;\nexports.popperOffsets = popperOffsets$1;\nexports.preventOverflow = preventOverflow$1; //# sourceMappingURL=popper.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvZGlzdC9janMvcG9wcGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQ7QUFFQUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFFN0QsU0FBU0MsVUFBVUMsSUFBSTtJQUNyQixJQUFJQSxRQUFRLE1BQU07UUFDaEIsT0FBT0M7SUFDVDtJQUVBLElBQUlELEtBQUtFLFFBQVEsT0FBTyxtQkFBbUI7UUFDekMsSUFBSUMsZ0JBQWdCSCxLQUFLRyxhQUFhO1FBQ3RDLE9BQU9BLGdCQUFnQkEsY0FBY0MsV0FBVyxJQUFJSCxTQUFTQTtJQUMvRDtJQUVBLE9BQU9EO0FBQ1Q7QUFFQSxTQUFTSyxVQUFVTCxJQUFJO0lBQ3JCLElBQUlNLGFBQWFQLFVBQVVDLE1BQU1PLE9BQU87SUFDeEMsT0FBT1AsZ0JBQWdCTSxjQUFjTixnQkFBZ0JPO0FBQ3ZEO0FBRUEsU0FBU0MsY0FBY1IsSUFBSTtJQUN6QixJQUFJTSxhQUFhUCxVQUFVQyxNQUFNUyxXQUFXO0lBQzVDLE9BQU9ULGdCQUFnQk0sY0FBY04sZ0JBQWdCUztBQUN2RDtBQUVBLFNBQVNDLGFBQWFWLElBQUk7SUFDeEIsMEJBQTBCO0lBQzFCLElBQUksT0FBT1csZUFBZSxhQUFhO1FBQ3JDLE9BQU87SUFDVDtJQUVBLElBQUlMLGFBQWFQLFVBQVVDLE1BQU1XLFVBQVU7SUFDM0MsT0FBT1gsZ0JBQWdCTSxjQUFjTixnQkFBZ0JXO0FBQ3ZEO0FBRUEsSUFBSUMsTUFBTUMsS0FBS0QsR0FBRztBQUNsQixJQUFJRSxNQUFNRCxLQUFLQyxHQUFHO0FBQ2xCLElBQUlDLFFBQVFGLEtBQUtFLEtBQUs7QUFFdEIsU0FBU0M7SUFDUCxJQUFJQyxTQUFTQyxVQUFVQyxhQUFhO0lBRXBDLElBQUlGLFVBQVUsUUFBUUEsT0FBT0csTUFBTSxJQUFJQyxNQUFNQyxPQUFPLENBQUNMLE9BQU9HLE1BQU0sR0FBRztRQUNuRSxPQUFPSCxPQUFPRyxN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WUFBWSxHQUFHd1o7QUFDZnhaLFlBQVksR0FBR2dlO0FBQ2ZoZSxjQUFjLEdBQUdzVztBQUNqQnRXLHVCQUF1QixHQUFHMlE7QUFDMUIzUSxxQkFBcUIsR0FBR29UO0FBQ3hCcFQsdUJBQXVCLEdBQUdzYyxtQkFDMUIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZHlncmFtbS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9kaXN0L2Nqcy9wb3BwZXIuanM/ZDcwMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwb3BwZXJqcy9jb3JlIHYyLjExLjggLSBNSVQgTGljZW5zZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuSFRNTEVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChub2RlKSB7XG4gIC8vIElFIDExIGhhcyBubyBTaGFkb3dSb290XG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5TaGFkb3dSb290O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XG59XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG5cbmZ1bmN0aW9uIGdldFVBU3RyaW5nKCkge1xuICB2YXIgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG5cbiAgaWYgKHVhRGF0YSAhPSBudWxsICYmIHVhRGF0YS5icmFuZHMgJiYgQXJyYXkuaXNBcnJheSh1YURhdGEuYnJhbmRzKSkge1xuICAgIHJldHVybiB1YURhdGEuYnJhbmRzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uYnJhbmQgKyBcIi9cIiArIGl0ZW0udmVyc2lvbjtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cblxuICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn1cblxuZnVuY3Rpb24gaXNMYXlvdXRWaWV3cG9ydCgpIHtcbiAgcmV0dXJuICEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3kpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuXG4gIGlmIChpbmNsdWRlU2NhbGUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHNjYWxlWCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggPiAwID8gcm91bmQoY2xpZW50UmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEgOiAxO1xuICAgIHNjYWxlWSA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ID4gMCA/IHJvdW5kKGNsaWVudFJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEgOiAxO1xuICB9XG5cbiAgdmFyIF9yZWYgPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3csXG4gICAgICB2aXN1YWxWaWV3cG9ydCA9IF9yZWYudmlzdWFsVmlld3BvcnQ7XG5cbiAgdmFyIGFkZFZpc3VhbE9mZnNldHMgPSAhaXNMYXlvdXRWaWV3cG9ydCgpICYmIGlzRml4ZWRTdHJhdGVneTtcbiAgdmFyIHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0IDogMCkpIC8gc2NhbGVYO1xuICB2YXIgeSA9IChjbGllbnRSZWN0LnRvcCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wIDogMCkpIC8gc2NhbGVZO1xuICB2YXIgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGVYO1xuICB2YXIgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICBsZWZ0OiB4LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEhUTUxFbGVtZW50U2Nyb2xsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXROb2RlU2Nyb2xsKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IGdldFdpbmRvdyhub2RlKSB8fCAhaXNIVE1MRWxlbWVudChub2RlKSkge1xuICAgIHJldHVybiBnZXRXaW5kb3dTY3JvbGwobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50U2Nyb2xsKG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQgPyAoZWxlbWVudC5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgcmV0dXJuICgoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gIGVsZW1lbnQuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcbiAgLy8gaXQncyBub3QgYW4gaXNzdWUuIEkgZG9uJ3QgdGhpbmsgYW55b25lIGV2ZXIgc3BlY2lmaWVzIHdpZHRoIG9uIDxodG1sPlxuICAvLyBhbnl3YXkuXG4gIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXG4gIC8vIHRoaXMgKGUuZy4gRWRnZSAyMDE5LCBJRTExLCBTYWZhcmkpXG4gIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59XG5cbmZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIGlzU2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gRmlyZWZveCB3YW50cyB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WTtcblxuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKTtcbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50U2NhbGVkKGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gcm91bmQocmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XG4gIHZhciBzY2FsZVkgPSByb3VuZChyZWN0LmhlaWdodCkgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxO1xuICByZXR1cm4gc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMTtcbn0gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxuLy8gQ29tcG9zaXRlIG1lYW5zIGl0IHRha2VzIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zIGFzIHdlbGwgYXMgbGF5b3V0LlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50SXNTY2FsZWQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNFbGVtZW50U2NhbGVkKG9mZnNldFBhcmVudCk7XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudElzU2NhbGVkLCBpc0ZpeGVkKTtcbiAgdmFyIHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgICBpc1Njcm9sbFBhcmVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgb2Zmc2V0cyA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUpO1xuICAgICAgb2Zmc2V0cy54ICs9IG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbi8vIG1lYW5zIGl0IGRvZXNuJ3QgdGFrZSBpbnRvIGFjY291bnQgdHJhbnNmb3Jtcy5cblxuZnVuY3Rpb24gZ2V0TGF5b3V0UmVjdChlbGVtZW50KSB7XG4gIHZhciBjbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpOyAvLyBVc2UgdGhlIGNsaWVudFJlY3Qgc2l6ZXMgaWYgaXQncyBub3QgYmVlbiB0cmFuc2Zvcm1lZC5cbiAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMjIzXG5cbiAgdmFyIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LndpZHRoIC0gd2lkdGgpIDw9IDEpIHtcbiAgICB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC5oZWlnaHQgLSBoZWlnaHQpIDw9IDEpIHtcbiAgICBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgIHk6IGVsZW1lbnQub2Zmc2V0VG9wLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiAoLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgZWxlbWVudC5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICBlbGVtZW50LnBhcmVudE5vZGUgfHwgKCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIGlzU2hhZG93Um9vdChlbGVtZW50KSA/IGVsZW1lbnQuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIC8vIGZhbGxiYWNrXG5cbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59XG5cbi8qXG5naXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xudW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcbnJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4qL1xuXG5mdW5jdGlvbiBsaXN0U2Nyb2xsUGFyZW50cyhlbGVtZW50LCBsaXN0KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQgPT09ICgoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHkpO1xuICB2YXIgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc1Njcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpID8gc2Nyb2xsUGFyZW50IDogW10pIDogc2Nyb2xsUGFyZW50O1xuICB2YXIgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xuICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xufVxuXG5mdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5kZXhPZihnZXROb2RlTmFtZShlbGVtZW50KSkgPj0gMDtcbn1cblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59IC8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXG4vLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcblxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICB2YXIgaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuICB2YXIgaXNJRSA9IC9UcmlkZW50L2kudGVzdChnZXRVQVN0cmluZygpKTtcblxuICBpZiAoaXNJRSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgLy8gSW4gSUUgOSwgMTAgYW5kIDExIGZpeGVkIGVsZW1lbnRzIGNvbnRhaW5pbmcgYmxvY2sgaXMgYWx3YXlzIGVzdGFibGlzaGVkIGJ5IHRoZSB2aWV3cG9ydFxuICAgIHZhciBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50Q3NzLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIGlmIChpc1NoYWRvd1Jvb3QoY3VycmVudE5vZGUpKSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xuICB9XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMCkge1xuICAgIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG5cbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn1cblxudmFyIHRvcCA9ICd0b3AnO1xudmFyIGJvdHRvbSA9ICdib3R0b20nO1xudmFyIHJpZ2h0ID0gJ3JpZ2h0JztcbnZhciBsZWZ0ID0gJ2xlZnQnO1xudmFyIGF1dG8gPSAnYXV0byc7XG52YXIgYmFzZVBsYWNlbWVudHMgPSBbdG9wLCBib3R0b20sIHJpZ2h0LCBsZWZ0XTtcbnZhciBzdGFydCA9ICdzdGFydCc7XG52YXIgZW5kID0gJ2VuZCc7XG52YXIgY2xpcHBpbmdQYXJlbnRzID0gJ2NsaXBwaW5nUGFyZW50cyc7XG52YXIgdmlld3BvcnQgPSAndmlld3BvcnQnO1xudmFyIHBvcHBlciA9ICdwb3BwZXInO1xudmFyIHJlZmVyZW5jZSA9ICdyZWZlcmVuY2UnO1xudmFyIHZhcmlhdGlvblBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovYmFzZVBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTtcbnZhciBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL1tdLmNvbmNhdChiYXNlUGxhY2VtZW50cywgW2F1dG9dKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQsIHBsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7IC8vIG1vZGlmaWVycyB0aGF0IG5lZWQgdG8gcmVhZCB0aGUgRE9NXG5cbnZhciBiZWZvcmVSZWFkID0gJ2JlZm9yZVJlYWQnO1xudmFyIHJlYWQgPSAncmVhZCc7XG52YXIgYWZ0ZXJSZWFkID0gJ2FmdGVyUmVhZCc7IC8vIHB1cmUtbG9naWMgbW9kaWZpZXJzXG5cbnZhciBiZWZvcmVNYWluID0gJ2JlZm9yZU1haW4nO1xudmFyIG1haW4gPSAnbWFpbic7XG52YXIgYWZ0ZXJNYWluID0gJ2FmdGVyTWFpbic7IC8vIG1vZGlmaWVyIHdpdGggdGhlIHB1cnBvc2UgdG8gd3JpdGUgdG8gdGhlIERPTSAob3Igd3JpdGUgaW50byBhIGZyYW1ld29yayBzdGF0ZSlcblxudmFyIGJlZm9yZVdyaXRlID0gJ2JlZm9yZVdyaXRlJztcbnZhciB3cml0ZSA9ICd3cml0ZSc7XG52YXIgYWZ0ZXJXcml0ZSA9ICdhZnRlcldyaXRlJztcbnZhciBtb2RpZmllclBoYXNlcyA9IFtiZWZvcmVSZWFkLCByZWFkLCBhZnRlclJlYWQsIGJlZm9yZU1haW4sIG1haW4sIGFmdGVyTWFpbiwgYmVmb3JlV3JpdGUsIHdyaXRlLCBhZnRlcldyaXRlXTtcblxuZnVuY3Rpb24gb3JkZXIobW9kaWZpZXJzKSB7XG4gIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIG1hcC5zZXQobW9kaWZpZXIubmFtZSwgbW9kaWZpZXIpO1xuICB9KTsgLy8gT24gdmlzaXRpbmcgb2JqZWN0LCBjaGVjayBmb3IgaXRzIGRlcGVuZGVuY2llcyBhbmQgdmlzaXQgdGhlbSByZWN1cnNpdmVseVxuXG4gIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXIpIHtcbiAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcbiAgICB2YXIgcmVxdWlyZXMgPSBbXS5jb25jYXQobW9kaWZpZXIucmVxdWlyZXMgfHwgW10sIG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xuICAgIHJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XG4gICAgICAgIHZhciBkZXBNb2RpZmllciA9IG1hcC5nZXQoZGVwKTtcblxuICAgICAgICBpZiAoZGVwTW9kaWZpZXIpIHtcbiAgICAgICAgICBzb3J0KGRlcE1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3VsdC5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmICghdmlzaXRlZC5oYXMobW9kaWZpZXIubmFtZSkpIHtcbiAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxuICAgICAgc29ydChtb2RpZmllcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xuICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyKG1vZGlmaWVycyk7IC8vIG9yZGVyIGJhc2VkIG9uIHBoYXNlXG5cbiAgcmV0dXJuIG1vZGlmaWVyUGhhc2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwaGFzZSkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgcmV0dXJuIG1vZGlmaWVyLnBoYXNlID09PSBwaGFzZTtcbiAgICB9KSk7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgdmFyIHBlbmRpbmc7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtZXJnZUJ5TmFtZShtb2RpZmllcnMpIHtcbiAgdmFyIG1lcmdlZCA9IG1vZGlmaWVycy5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZCwgY3VycmVudCkge1xuICAgIHZhciBleGlzdGluZyA9IG1lcmdlZFtjdXJyZW50Lm5hbWVdO1xuICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmcgPyBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZywgY3VycmVudCwge1xuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3Rpbmcub3B0aW9ucywgY3VycmVudC5vcHRpb25zKSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLmRhdGEsIGN1cnJlbnQuZGF0YSlcbiAgICB9KSA6IGN1cnJlbnQ7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pOyAvLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LnZhbHVlc1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG1lcmdlZFtrZXldO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIHZhciB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG5cbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7XG4gICAgdmFyIGxheW91dFZpZXdwb3J0ID0gaXNMYXlvdXRWaWV3cG9ydCgpO1xuXG4gICAgaWYgKGxheW91dFZpZXdwb3J0IHx8ICFsYXlvdXRWaWV3cG9ydCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHggKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpLFxuICAgIHk6IHlcbiAgfTtcbn1cblxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgd2luU2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpO1xuICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcbiAgdmFyIHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKTtcbiAgdmFyIGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkgPyBib2R5LnNjcm9sbEhlaWdodCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudEhlaWdodCA6IDApO1xuICB2YXIgeCA9IC13aW5TY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIHZhciB5ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XG5cbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgZWxzZSBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgICAgdmFyIG5leHQgPSBjaGlsZDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cblxuXG4gICAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgICAgfSB3aGlsZSAobmV4dCk7XG4gICAgfSAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG5cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge1xuICAgIGxlZnQ6IHJlY3QueCxcbiAgICB0b3A6IHJlY3QueSxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBmYWxzZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuICByZWN0LnRvcCA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIHJlY3QubGVmdCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC53aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3QuaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QueCA9IHJlY3QubGVmdDtcbiAgcmVjdC55ID0gcmVjdC50b3A7XG4gIHJldHVybiByZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIHtcbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50ID09PSB2aWV3cG9ydCA/IHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSkgOiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpID8gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSA6IHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xufSAvLyBBIFwiY2xpcHBpbmcgcGFyZW50XCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXG4vLyBgaW5pdGlhbGBcblxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkge1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gbGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG4gIHZhciBjYW5Fc2NhcGVDbGlwcGluZyA9IFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24pID49IDA7XG4gIHZhciBjbGlwcGVyRWxlbWVudCA9IGNhbkVzY2FwZUNsaXBwaW5nICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gIGlmICghaXNFbGVtZW50KGNsaXBwZXJFbGVtZW50KSkge1xuICAgIHJldHVybiBbXTtcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMTQxNFxuXG5cbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50cy5maWx0ZXIoZnVuY3Rpb24gKGNsaXBwaW5nUGFyZW50KSB7XG4gICAgcmV0dXJuIGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgJiYgY29udGFpbnMoY2xpcHBpbmdQYXJlbnQsIGNsaXBwZXJFbGVtZW50KSAmJiBnZXROb2RlTmFtZShjbGlwcGluZ1BhcmVudCkgIT09ICdib2R5JztcbiAgfSk7XG59IC8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIHBhcmVudHNcblxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoZWxlbWVudCwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSwgc3RyYXRlZ3kpIHtcbiAgdmFyIG1haW5DbGlwcGluZ1BhcmVudHMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nUGFyZW50cycgPyBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gW10uY29uY2F0KG1haW5DbGlwcGluZ1BhcmVudHMsIFtyb290Qm91bmRhcnldKTtcbiAgdmFyIGZpcnN0Q2xpcHBpbmdQYXJlbnQgPSBjbGlwcGluZ1BhcmVudHNbMF07XG4gIHZhciBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ1BhcmVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2NSZWN0LCBjbGlwcGluZ1BhcmVudCkge1xuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBmaXJzdENsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkpO1xuICBjbGlwcGluZ1JlY3Qud2lkdGggPSBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LmhlaWdodCA9IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wO1xuICBjbGlwcGluZ1JlY3QueCA9IGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QueSA9IGNsaXBwaW5nUmVjdC50b3A7XG4gIHJldHVybiBjbGlwcGluZ1JlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG5cbmZ1bmN0aW9uIGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gIHZhciBvZmZzZXRzO1xuXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBib3R0b206XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBlbmQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBnZXRGcmVzaFNpZGVPYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChwYWRkaW5nT2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSwgcGFkZGluZ09iamVjdCk7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZFRvSGFzaE1hcCh2YWx1ZSwga2V5cykge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc2hNYXAsIGtleSkge1xuICAgIGhhc2hNYXBba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBoYXNoTWFwO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMkcGxhY2VtZW50ID09PSB2b2lkIDAgPyBzdGF0ZS5wbGFjZW1lbnQgOiBfb3B0aW9ucyRwbGFjZW1lbnQsXG4gICAgICBfb3B0aW9ucyRzdHJhdGVneSA9IF9vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgc3RyYXRlZ3kgPSBfb3B0aW9ucyRzdHJhdGVneSA9PT0gdm9pZCAwID8gc3RhdGUuc3RyYXRlZ3kgOiBfb3B0aW9ucyRzdHJhdGVneSxcbiAgICAgIF9vcHRpb25zJGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zJGJvdW5kYXJ5ID09PSB2b2lkIDAgPyBjbGlwcGluZ1BhcmVudHMgOiBfb3B0aW9ucyRib3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9PT0gdm9pZCAwID8gdmlld3BvcnQgOiBfb3B0aW9ucyRyb290Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRlbGVtZW50Q29udGUgPSBfb3B0aW9ucy5lbGVtZW50Q29udGV4dCxcbiAgICAgIGVsZW1lbnRDb250ZXh0ID0gX29wdGlvbnMkZWxlbWVudENvbnRlID09PSB2b2lkIDAgPyBwb3BwZXIgOiBfb3B0aW9ucyRlbGVtZW50Q29udGUsXG4gICAgICBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9IF9vcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zJHBhZGRpbmcgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRwYWRkaW5nO1xuICB2YXIgcGFkZGluZ09iamVjdCA9IG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG4gIHZhciBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHJlZmVyZW5jZSA6IHBvcHBlcjtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICB2YXIgY2xpcHBpbmdDbGllbnRSZWN0ID0gZ2V0Q2xpcHBpbmdSZWN0KGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IGdldERvY3VtZW50RWxlbWVudChzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSk7XG4gIHZhciByZWZlcmVuY2VDbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICBlbGVtZW50OiBwb3BwZXJSZWN0LFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pO1xuICB2YXIgcG9wcGVyQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoT2JqZWN0LmFzc2lnbih7fSwgcG9wcGVyUmVjdCwgcG9wcGVyT2Zmc2V0cykpO1xuICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuXG4gIHZhciBvdmVyZmxvd09mZnNldHMgPSB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgfTtcbiAgdmFyIG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDsgLy8gT2Zmc2V0cyBjYW4gYmUgYXBwbGllZCBvbmx5IHRvIHRoZSBwb3BwZXIgZWxlbWVudFxuXG4gIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0RGF0YVtwbGFjZW1lbnRdO1xuICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICB2YXIgYXhpcyA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAneScgOiAneCc7XG4gICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvdmVyZmxvd09mZnNldHM7XG59XG5cbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwb3BwZXJHZW5lcmF0b3IoZ2VuZXJhdG9yT3B0aW9ucykge1xuICBpZiAoZ2VuZXJhdG9yT3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgZ2VuZXJhdG9yT3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9nZW5lcmF0b3JPcHRpb25zID0gZ2VuZXJhdG9yT3B0aW9ucyxcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRNb2RpZmllcnMsXG4gICAgICBkZWZhdWx0TW9kaWZpZXJzID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmID09PSB2b2lkIDAgPyBbXSA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZixcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHRPcHRpb25zID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9PT0gdm9pZCAwID8gREVGQVVMVF9PUFRJT05TIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmMjtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVBvcHBlcihyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIGRlZmF1bHRPcHRpb25zKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlcjogcG9wcGVyXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfTtcbiAgICB2YXIgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIHZhciBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHZhciBpbnN0YW5jZSA9IHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMoc2V0T3B0aW9uc0FjdGlvbikge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzZXRPcHRpb25zQWN0aW9uID09PSAnZnVuY3Rpb24nID8gc2V0T3B0aW9uc0FjdGlvbihzdGF0ZS5vcHRpb25zKSA6IHNldE9wdGlvbnNBY3Rpb247XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgc3RhdGUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBzdGF0ZS5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGlzRWxlbWVudChyZWZlcmVuY2UpID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlKSA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICBwb3BwZXI6IGxpc3RTY3JvbGxQYXJlbnRzKHBvcHBlcilcbiAgICAgICAgfTsgLy8gT3JkZXJzIHRoZSBtb2RpZmllcnMgYmFzZWQgb24gdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCBgcGhhc2VgXG4gICAgICAgIC8vIHByb3BlcnRpZXNcblxuICAgICAgICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyTW9kaWZpZXJzKG1lcmdlQnlOYW1lKFtdLmNvbmNhdChkZWZhdWx0TW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycykpKTsgLy8gU3RyaXAgb3V0IGRpc2FibGVkIG1vZGlmaWVyc1xuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLmVuYWJsZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBydW5Nb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFN5bmMgdXBkYXRlIOKAkyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAvLyBsb2dpYy5cbiAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKGlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9zdGF0ZSRlbGVtZW50cyA9IHN0YXRlLmVsZW1lbnRzLFxuICAgICAgICAgICAgcmVmZXJlbmNlID0gX3N0YXRlJGVsZW1lbnRzLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIHBvcHBlciA9IF9zdGF0ZSRlbGVtZW50cy5wb3BwZXI7IC8vIERvbid0IHByb2NlZWQgaWYgYHJlZmVyZW5jZWAgb3IgYHBvcHBlcmAgYXJlIG5vdCB2YWxpZCBlbGVtZW50c1xuICAgICAgICAvLyBhbnltb3JlXG5cbiAgICAgICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIGFuZCBwb3BwZXIgcmVjdHMgdG8gYmUgcmVhZCBieSBtb2RpZmllcnNcblxuXG4gICAgICAgIHN0YXRlLnJlY3RzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogZ2V0Q29tcG9zaXRlUmVjdChyZWZlcmVuY2UsIGdldE9mZnNldFBhcmVudChwb3BwZXIpLCBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnKSxcbiAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKVxuICAgICAgICB9OyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXNldCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUuIFRoZVxuICAgICAgICAvLyBtb3N0IGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0aGUgYGZsaXBgIG1vZGlmaWVyIGNoYW5naW5nIHRoZVxuICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBsb2dpYyB3YXMgcHJldmlvdXNseSByYW4gZm9yIHRoZSBwcmV2aW91cyBwbGFjZW1lbnQgYW5kIGlzIHRoZXJlZm9yZVxuICAgICAgICAvLyBzdGFsZS9pbmNvcnJlY3RcblxuICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcbiAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgcGVyc2lzdCBhbmQgaXMgZnJlc2ggb24gZWFjaCB1cGRhdGUuXG4gICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubW9kaWZpZXJzRGF0YVttb2RpZmllci5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIG1vZGlmaWVyLmRhdGEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpZiAoc3RhdGUucmVzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZSA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnNbaW5kZXhdLFxuICAgICAgICAgICAgICBmbiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5mbixcbiAgICAgICAgICAgICAgX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5vcHRpb25zLFxuICAgICAgICAgICAgICBfb3B0aW9ucyA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPT09IHZvaWQgMCA/IHt9IDogX3N0YXRlJG9yZGVyZWRNb2RpZmllMixcbiAgICAgICAgICAgICAgbmFtZSA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5uYW1lO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3RhdGUgPSBmbih7XG4gICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgb3B0aW9uczogX29wdGlvbnMsXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZVxuICAgICAgICAgICAgfSkgfHwgc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUg4oCTIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IChkZWJvdW5jZWQgdG8gcnVuIGF0IG1vc3Qgb25jZS1wZXItdGljaylcbiAgICAgIHVwZGF0ZTogZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBpc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICBpZiAoIWlzRGVzdHJveWVkICYmIG9wdGlvbnMub25GaXJzdFVwZGF0ZSkge1xuICAgICAgICBvcHRpb25zLm9uRmlyc3RVcGRhdGUoc3RhdGUpO1xuICAgICAgfVxuICAgIH0pOyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAvLyB1cGRhdGUgY3ljbGUgcnVucy4gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB1cGRhdGVcbiAgICAvLyBjeWNsZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIG1vZGlmaWVyIGFkZHMgc29tZSBwZXJzaXN0ZW50IGRhdGEgdGhhdFxuICAgIC8vIG90aGVyIG1vZGlmaWVycyBuZWVkIHRvIHVzZSwgYnV0IHRoZSBtb2RpZmllciBpcyBydW4gYWZ0ZXIgdGhlIGRlcGVuZGVudFxuICAgIC8vIG9uZS5cblxuICAgIGZ1bmN0aW9uIHJ1bk1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgICAgIF9yZWYkb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfcmVmJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZiRvcHRpb25zLFxuICAgICAgICAgICAgZWZmZWN0ID0gX3JlZi5lZmZlY3Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgY2xlYW51cEZuID0gZWZmZWN0KHtcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XG5cbiAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSk7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufVxuXG52YXIgcGFzc2l2ZSA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gZWZmZWN0JDIoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXG4gICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBldmVudExpc3RlbmVycyA9IHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCQyLFxuICBkYXRhOiB7fVxufTtcblxuZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxuICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgcG9wcGVyT2Zmc2V0cyQxID0ge1xuICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAncmVhZCcsXG4gIGZuOiBwb3BwZXJPZmZzZXRzLFxuICBkYXRhOiB7fVxufTtcblxudmFyIHVuc2V0U2lkZXMgPSB7XG4gIHRvcDogJ2F1dG8nLFxuICByaWdodDogJ2F1dG8nLFxuICBib3R0b206ICdhdXRvJyxcbiAgbGVmdDogJ2F1dG8nXG59OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuXG5mdW5jdGlvbiByb3VuZE9mZnNldHNCeURQUihfcmVmLCB3aW4pIHtcbiAgdmFyIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55O1xuICB2YXIgZHByID0gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgcmV0dXJuIHtcbiAgICB4OiByb3VuZCh4ICogZHByKSAvIGRwciB8fCAwLFxuICAgIHk6IHJvdW5kKHkgKiBkcHIpIC8gZHByIHx8IDBcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcbiAgdmFyIF9PYmplY3QkYXNzaWduMjtcblxuICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxuICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmMi5wbGFjZW1lbnQsXG4gICAgICB2YXJpYXRpb24gPSBfcmVmMi52YXJpYXRpb24sXG4gICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfcmVmMi5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzID0gX3JlZjIucm91bmRPZmZzZXRzLFxuICAgICAgaXNGaXhlZCA9IF9yZWYyLmlzRml4ZWQ7XG4gIHZhciBfb2Zmc2V0cyR4ID0gb2Zmc2V0cy54LFxuICAgICAgeCA9IF9vZmZzZXRzJHggPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR4LFxuICAgICAgX29mZnNldHMkeSA9IG9mZnNldHMueSxcbiAgICAgIHkgPSBfb2Zmc2V0cyR5ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeTtcblxuICB2YXIgX3JlZjMgPSB0eXBlb2Ygcm91bmRPZmZzZXRzID09PSAnZnVuY3Rpb24nID8gcm91bmRPZmZzZXRzKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWYzLng7XG4gIHkgPSBfcmVmMy55O1xuICB2YXIgaGFzWCA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3gnKTtcbiAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG4gIHZhciBzaWRlWCA9IGxlZnQ7XG4gIHZhciBzaWRlWSA9IHRvcDtcbiAgdmFyIHdpbiA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycgJiYgcG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XG5cblxuICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblxuICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCB8fCAocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWSA9IGJvdHRvbTtcbiAgICAgIHZhciBvZmZzZXRZID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQuaGVpZ2h0IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbaGVpZ2h0UHJvcF07XG4gICAgICB5IC09IG9mZnNldFkgLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQgfHwgKHBsYWNlbWVudCA9PT0gdG9wIHx8IHBsYWNlbWVudCA9PT0gYm90dG9tKSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVggPSByaWdodDtcbiAgICAgIHZhciBvZmZzZXRYID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQud2lkdGggOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFt3aWR0aFByb3BdO1xuICAgICAgeCAtPSBvZmZzZXRYIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XG5cbiAgdmFyIF9yZWY0ID0gcm91bmRPZmZzZXRzID09PSB0cnVlID8gcm91bmRPZmZzZXRzQnlEUFIoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9LCBnZXRXaW5kb3cocG9wcGVyKSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWY0Lng7XG4gIHkgPSBfcmVmNC55O1xuXG4gIGlmIChncHVBY2NlbGVyYXRpb24pIHtcbiAgICB2YXIgX09iamVjdCRhc3NpZ247XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bc2lkZVldID0gaGFzWSA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbltzaWRlWF0gPSBoYXNYID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduLnRyYW5zZm9ybSA9ICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU3R5bGVzKF9yZWY1KSB7XG4gIHZhciBzdGF0ZSA9IF9yZWY1LnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWY1Lm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPSBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGdwdUFjY2VsZXJhdCxcbiAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcbiAgICAgIGFkYXB0aXZlID0gX29wdGlvbnMkYWRhcHRpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhZGFwdGl2ZSxcbiAgICAgIF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9IG9wdGlvbnMucm91bmRPZmZzZXRzLFxuICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogZ3B1QWNjZWxlcmF0aW9uLFxuICAgIGlzRml4ZWQ6IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCdcbiAgfTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgY29tcHV0ZVN0eWxlcyQxID0ge1xuICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICBmbjogY29tcHV0ZVN0eWxlcyxcbiAgZGF0YToge31cbn07XG5cbi8vIGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIEhUTUxFbGVtZW50cyBzdWNoIGFzIHBvcHBlciBhbmQgYXJyb3dcblxuZnVuY3Rpb24gYXBwbHlTdHlsZXMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlO1xuICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnN0eWxlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0byBleHRlbmQgdGhpcyBwcm9wZXJ0eSwgYnV0IGl0J3MgdGhlIG1vc3RcbiAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuXG5cbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdCQxKF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuICB2YXIgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgbGVmdDogJzAnLFxuICAgICAgdG9wOiAnMCcsXG4gICAgICBtYXJnaW46ICcwJ1xuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSxcbiAgICByZWZlcmVuY2U6IHt9XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgICAgdmFyIHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHN0YXRlLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHN0YXRlLnN0eWxlc1tuYW1lXSA6IGluaXRpYWxTdHlsZXNbbmFtZV0pOyAvLyBTZXQgYWxsIHZhbHVlcyB0byBhbiBlbXB0eSBzdHJpbmcgdG8gdW5zZXQgdGhlbVxuXG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcbiAgICAgICAgc3R5bGVbcHJvcGVydHldID0gJyc7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgYXBwbHlTdHlsZXMkMSA9IHtcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBhcHBseVN0eWxlcyxcbiAgZWZmZWN0OiBlZmZlY3QkMSxcbiAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddXG59O1xuXG5mdW5jdGlvbiBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHJlY3RzLCBvZmZzZXQpIHtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciBpbnZlcnREaXN0YW5jZSA9IFtsZWZ0LCB0b3BdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcblxuICB2YXIgX3JlZiA9IHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicgPyBvZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgcmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KSkgOiBvZmZzZXQsXG4gICAgICBza2lkZGluZyA9IF9yZWZbMF0sXG4gICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XG5cbiAgc2tpZGRpbmcgPSBza2lkZGluZyB8fCAwO1xuICBkaXN0YW5jZSA9IChkaXN0YW5jZSB8fCAwKSAqIGludmVydERpc3RhbmNlO1xuICByZXR1cm4gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyB7XG4gICAgeDogZGlzdGFuY2UsXG4gICAgeTogc2tpZGRpbmdcbiAgfSA6IHtcbiAgICB4OiBza2lkZGluZyxcbiAgICB5OiBkaXN0YW5jZVxuICB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmMi5uYW1lO1xuICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXG4gICAgICBvZmZzZXQgPSBfb3B0aW9ucyRvZmZzZXQgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9vcHRpb25zJG9mZnNldDtcbiAgdmFyIGRhdGEgPSBwbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxuICAgICAgeCA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC54LFxuICAgICAgeSA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC55O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IHg7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0geTtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxudmFyIG9mZnNldCQxID0ge1xuICBuYW1lOiAnb2Zmc2V0JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICBmbjogb2Zmc2V0XG59O1xuXG52YXIgaGFzaCQxID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2gkMVttYXRjaGVkXTtcbiAgfSk7XG59XG5cbnZhciBoYXNoID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBwbGFjZW1lbnRzIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gIHZhciBwbGFjZW1lbnRzJDEgPSB2YXJpYXRpb24gPyBmbGlwVmFyaWF0aW9ucyA/IHZhcmlhdGlvblBsYWNlbWVudHMgOiB2YXJpYXRpb25QbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSB2YXJpYXRpb247XG4gIH0pIDogYmFzZVBsYWNlbWVudHM7XG4gIHZhciBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMkMS5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhbGxvd2VkQXV0b1BsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpID49IDA7XG4gIH0pO1xuXG4gIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMkMTtcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG5cbiAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cblxuZnVuY3Rpb24gZmxpcChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZmxpcFZhcmlhdGlvID0gb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XG4gIHZhciBwcmVmZXJyZWRQbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG4gIHZhciBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnMgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcbiAgdmFyIHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50XS5jb25jYXQoZmFsbGJhY2tQbGFjZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcbiAgICB9KSA6IHBsYWNlbWVudCk7XG4gIH0sIFtdKTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgdmFyIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG5cbiAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KTtcbiAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XG5cbiAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XG4gICAgICBtYWluVmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB9XG5cbiAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB2YXIgY2hlY2tzID0gW107XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbX2Jhc2VQbGFjZW1lbnRdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0pKSB7XG4gICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNoZWNrc01hcC5zZXQocGxhY2VtZW50LCBjaGVja3MpO1xuICB9XG5cbiAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIOKAkyByZXNlYXJjaCBsYXRlclxuICAgIHZhciBudW1iZXJPZkNoZWNrcyA9IGZsaXBWYXJpYXRpb25zID8gMyA6IDE7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tzLnNsaWNlKDAsIF9pKS5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVjaztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gbnVtYmVyT2ZDaGVja3M7IF9pID4gMDsgX2ktLSkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gIH1cbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBmbGlwJDEgPSB7XG4gIG5hbWU6ICdmbGlwJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGZsaXAsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogZmFsc2VcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0QWx0QXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59XG5cbmZ1bmN0aW9uIHdpdGhpbihtaW4kMSwgdmFsdWUsIG1heCQxKSB7XG4gIHJldHVybiBtYXgobWluJDEsIG1pbih2YWx1ZSwgbWF4JDEpKTtcbn1cbmZ1bmN0aW9uIHdpdGhpbk1heENsYW1wKG1pbiwgdmFsdWUsIG1heCkge1xuICB2YXIgdiA9IHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpO1xuICByZXR1cm4gdiA+IG1heCA/IG1heCA6IHY7XG59XG5cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxuICAgICAgdGV0aGVyID0gX29wdGlvbnMkdGV0aGVyID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkdGV0aGVyLFxuICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXG4gICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XG4gIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XG4gIH0pO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcbiAgdmFyIG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgdGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gdGV0aGVyT2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogdGV0aGVyT2Zmc2V0O1xuICB2YXIgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldFZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogdGV0aGVyT2Zmc2V0VmFsdWUsXG4gICAgYWx0QXhpczogdGV0aGVyT2Zmc2V0VmFsdWVcbiAgfSA6IE9iamVjdC5hc3NpZ24oe1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGFsdEF4aXM6IDBcbiAgfSwgdGV0aGVyT2Zmc2V0VmFsdWUpO1xuICB2YXIgb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XSA6IG51bGw7XG4gIHZhciBkYXRhID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmICghcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDtcblxuICAgIHZhciBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgIHZhciBhbHRTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcbiAgICB2YXIgbWluJDEgPSBvZmZzZXQgKyBvdmVyZmxvd1ttYWluU2lkZV07XG4gICAgdmFyIG1heCQxID0gb2Zmc2V0IC0gb3ZlcmZsb3dbYWx0U2lkZV07XG4gICAgdmFyIGFkZGl0aXZlID0gdGV0aGVyID8gLXBvcHBlclJlY3RbbGVuXSAvIDIgOiAwO1xuICAgIHZhciBtaW5MZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gcmVmZXJlbmNlUmVjdFtsZW5dIDogcG9wcGVyUmVjdFtsZW5dO1xuICAgIHZhciBtYXhMZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gLXBvcHBlclJlY3RbbGVuXSA6IC1yZWZlcmVuY2VSZWN0W2xlbl07IC8vIFdlIG5lZWQgdG8gaW5jbHVkZSB0aGUgYXJyb3cgaW4gdGhlIGNhbGN1bGF0aW9uIHNvIHRoZSBhcnJvdyBkb2Vzbid0IGdvXG4gICAgLy8gb3V0c2lkZSB0aGUgcmVmZXJlbmNlIGJvdW5kc1xuXG4gICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICAgIHZhciBhcnJvd1JlY3QgPSB0ZXRoZXIgJiYgYXJyb3dFbGVtZW50ID8gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpIDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIHZhciBhcnJvd1BhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10gPyBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10ucGFkZGluZyA6IGdldEZyZXNoU2lkZU9iamVjdCgpO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNYXggPSBhcnJvd1BhZGRpbmdPYmplY3RbYWx0U2lkZV07IC8vIElmIHRoZSByZWZlcmVuY2UgbGVuZ3RoIGlzIHNtYWxsZXIgdGhhbiB0aGUgYXJyb3cgbGVuZ3RoLCB3ZSBkb24ndCB3YW50XG4gICAgLy8gdG8gaW5jbHVkZSBpdHMgZnVsbCBzaXplIGluIHRoZSBjYWxjdWxhdGlvbi4gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbFxuICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXG4gICAgLy8gcmVmZXJlbmNlIGlzIG5vdCBvdmVyZmxvd2luZyBhcyB3ZWxsIChlLmcuIHZpcnR1YWwgZWxlbWVudHMgd2l0aCBub1xuICAgIC8vIHdpZHRoIG9yIGhlaWdodClcblxuICAgIHZhciBhcnJvd0xlbiA9IHdpdGhpbigwLCByZWZlcmVuY2VSZWN0W2xlbl0sIGFycm93UmVjdFtsZW5dKTtcbiAgICB2YXIgbWluT2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiAtIGFkZGl0aXZlIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtaW5MZW4gLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgKyBhZGRpdGl2ZSArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWF4TGVuICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3cgJiYgZ2V0T2Zmc2V0UGFyZW50KHN0YXRlLmVsZW1lbnRzLmFycm93KTtcbiAgICB2YXIgY2xpZW50T2Zmc2V0ID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBtYWluQXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50VG9wIHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRMZWZ0IHx8IDAgOiAwO1xuICAgIHZhciBvZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJCA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbbWFpbkF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkIDogMDtcbiAgICB2YXIgdGV0aGVyTWluID0gb2Zmc2V0ICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcbiAgICB2YXIgdGV0aGVyTWF4ID0gb2Zmc2V0ICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcbiAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IG1pbihtaW4kMSwgdGV0aGVyTWluKSA6IG1pbiQxLCBvZmZzZXQsIHRldGhlciA/IG1heChtYXgkMSwgdGV0aGVyTWF4KSA6IG1heCQxKTtcbiAgICBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcbiAgfVxuXG4gIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkMjtcblxuICAgIHZhciBfbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gdG9wIDogbGVmdDtcblxuICAgIHZhciBfYWx0U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBib3R0b20gOiByaWdodDtcblxuICAgIHZhciBfb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1thbHRBeGlzXTtcblxuICAgIHZhciBfbGVuID0gYWx0QXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcblxuICAgIHZhciBfbWF4ID0gX29mZnNldCAtIG92ZXJmbG93W19hbHRTaWRlXTtcblxuICAgIHZhciBpc09yaWdpblNpZGUgPSBbdG9wLCBsZWZ0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVthbHRBeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJDIgOiAwO1xuXG4gICAgdmFyIF90ZXRoZXJNaW4gPSBpc09yaWdpblNpZGUgPyBfbWluIDogX29mZnNldCAtIHJlZmVyZW5jZVJlY3RbX2xlbl0gLSBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcztcblxuICAgIHZhciBfdGV0aGVyTWF4ID0gaXNPcmlnaW5TaWRlID8gX29mZnNldCArIHJlZmVyZW5jZVJlY3RbX2xlbl0gKyBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcyA6IF9tYXg7XG5cbiAgICB2YXIgX3ByZXZlbnRlZE9mZnNldCA9IHRldGhlciAmJiBpc09yaWdpblNpZGUgPyB3aXRoaW5NYXhDbGFtcChfdGV0aGVyTWluLCBfb2Zmc2V0LCBfdGV0aGVyTWF4KSA6IHdpdGhpbih0ZXRoZXIgPyBfdGV0aGVyTWluIDogX21pbiwgX29mZnNldCwgdGV0aGVyID8gX3RldGhlck1heCA6IF9tYXgpO1xuXG4gICAgcG9wcGVyT2Zmc2V0c1thbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgcHJldmVudE92ZXJmbG93JDEgPSB7XG4gIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogcHJldmVudE92ZXJmbG93LFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddXG59O1xuXG52YXIgdG9QYWRkaW5nT2JqZWN0ID0gZnVuY3Rpb24gdG9QYWRkaW5nT2JqZWN0KHBhZGRpbmcsIHN0YXRlKSB7XG4gIHBhZGRpbmcgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IHBhZGRpbmcoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiBwYWRkaW5nO1xuICByZXR1cm4gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbn07XG5cbmZ1bmN0aW9uIGFycm93KF9yZWYpIHtcbiAgdmFyIF9zdGF0ZSRtb2RpZmllcnNEYXRhJDtcblxuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgYXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGlzVmVydGljYWwgPSBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgaWYgKCFhcnJvd0VsZW1lbnQgfHwgIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFkZGluZ09iamVjdCA9IHRvUGFkZGluZ09iamVjdChvcHRpb25zLnBhZGRpbmcsIHN0YXRlKTtcbiAgdmFyIGFycm93UmVjdCA9IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KTtcbiAgdmFyIG1pblByb3AgPSBheGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICB2YXIgbWF4UHJvcCA9IGF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICB2YXIgZW5kRGlmZiA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtsZW5dICsgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnBvcHBlcltsZW5dO1xuICB2YXIgc3RhcnREaWZmID0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGFycm93RWxlbWVudCk7XG4gIHZhciBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBheGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoIHx8IDAgOiAwO1xuICB2YXIgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgcG9wcGVyIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXNcbiAgLy8gb3V0c2lkZSBvZiB0aGUgcG9wcGVyIGJvdW5kc1xuXG4gIHZhciBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICB2YXIgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgdmFyIGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dSZWN0W2xlbl0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gIHZhciBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cblxuICB2YXIgYXhpc1Byb3AgPSBheGlzO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gKF9zdGF0ZSRtb2RpZmllcnNEYXRhJCA9IHt9LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSRbYXhpc1Byb3BdID0gb2Zmc2V0LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQuY2VudGVyT2Zmc2V0ID0gb2Zmc2V0IC0gY2VudGVyLCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQpO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xuXG4gIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDU1Mgc2VsZWN0b3JcblxuXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgYXJyb3ckMSA9IHtcbiAgbmFtZTogJ2Fycm93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGFycm93LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddXG59O1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCwgcHJldmVudGVkT2Zmc2V0cykge1xuICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XG4gICAgcHJldmVudGVkT2Zmc2V0cyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCAtIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoICsgcHJldmVudGVkT2Zmc2V0cy54LFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQgKyBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGggLSBwcmV2ZW50ZWRPZmZzZXRzLnhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5zb21lKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93W3NpZGVdID49IDA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoaWRlKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHByZXZlbnRlZE9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdztcbiAgdmFyIHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgfSk7XG4gIHZhciBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgfSk7XG4gIHZhciByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhyZWZlcmVuY2VPdmVyZmxvdywgcmVmZXJlbmNlUmVjdCk7XG4gIHZhciBwb3BwZXJFc2NhcGVPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocG9wcGVyQWx0T3ZlcmZsb3csIHBvcHBlclJlY3QsIHByZXZlbnRlZE9mZnNldHMpO1xuICB2YXIgaXNSZWZlcmVuY2VIaWRkZW4gPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzKTtcbiAgdmFyIGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOiByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogcG9wcGVyRXNjYXBlT2Zmc2V0cyxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbjogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgaGFzUG9wcGVyRXNjYXBlZDogaGFzUG9wcGVyRXNjYXBlZFxuICB9O1xuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW4nOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICAnZGF0YS1wb3BwZXItZXNjYXBlZCc6IGhhc1BvcHBlckVzY2FwZWRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgaGlkZSQxID0ge1xuICBuYW1lOiAnaGlkZScsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J10sXG4gIGZuOiBoaWRlXG59O1xuXG52YXIgZGVmYXVsdE1vZGlmaWVycyQxID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzJDEsIGNvbXB1dGVTdHlsZXMkMSwgYXBwbHlTdHlsZXMkMV07XG52YXIgY3JlYXRlUG9wcGVyJDEgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVycyQxXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgZGVmYXVsdE1vZGlmaWVycyA9IFtldmVudExpc3RlbmVycywgcG9wcGVyT2Zmc2V0cyQxLCBjb21wdXRlU3R5bGVzJDEsIGFwcGx5U3R5bGVzJDEsIG9mZnNldCQxLCBmbGlwJDEsIHByZXZlbnRPdmVyZmxvdyQxLCBhcnJvdyQxLCBoaWRlJDFdO1xudmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnRzLmFwcGx5U3R5bGVzID0gYXBwbHlTdHlsZXMkMTtcbmV4cG9ydHMuYXJyb3cgPSBhcnJvdyQxO1xuZXhwb3J0cy5jb21wdXRlU3R5bGVzID0gY29tcHV0ZVN0eWxlcyQxO1xuZXhwb3J0cy5jcmVhdGVQb3BwZXIgPSBjcmVhdGVQb3BwZXI7XG5leHBvcnRzLmNyZWF0ZVBvcHBlckxpdGUgPSBjcmVhdGVQb3BwZXIkMTtcbmV4cG9ydHMuZGVmYXVsdE1vZGlmaWVycyA9IGRlZmF1bHRNb2RpZmllcnM7XG5leHBvcnRzLmRldGVjdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3c7XG5leHBvcnRzLmV2ZW50TGlzdGVuZXJzID0gZXZlbnRMaXN0ZW5lcnM7XG5leHBvcnRzLmZsaXAgPSBmbGlwJDE7XG5leHBvcnRzLmhpZGUgPSBoaWRlJDE7XG5leHBvcnRzLm9mZnNldCA9IG9mZnNldCQxO1xuZXhwb3J0cy5wb3BwZXJHZW5lcmF0b3IgPSBwb3BwZXJHZW5lcmF0b3I7XG5leHBvcnRzLnBvcHBlck9mZnNldHMgPSBwb3BwZXJPZmZzZXRzJDE7XG5leHBvcnRzLnByZXZlbnRPdmVyZmxvdyA9IHByZXZlbnRPdmVyZmxvdyQxO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9wcGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0V2luZG93Iiwibm9kZSIsIndpbmRvdyIsInRvU3RyaW5nIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiaXNFbGVtZW50IiwiT3duRWxlbWVudCIsIkVsZW1lbnQiLCJpc0hUTUxFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc1NoYWRvd1Jvb3QiLCJTaGFkb3dSb290IiwibWF4IiwiTWF0aCIsIm1pbiIsInJvdW5kIiwiZ2V0VUFTdHJpbmciLCJ1YURhdGEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnREYXRhIiwiYnJhbmRzIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiaXRlbSIsImJyYW5kIiwidmVyc2lvbiIsImpvaW4iLCJ1c2VyQWdlbnQiLCJpc0xheW91dFZpZXdwb3J0IiwidGVzdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImVsZW1lbnQiLCJpbmNsdWRlU2NhbGUiLCJpc0ZpeGVkU3RyYXRlZ3kiLCJjbGllbnRSZWN0Iiwic2NhbGVYIiwic2NhbGVZIiwib2Zmc2V0V2lkdGgiLCJ3aWR0aCIsIm9mZnNldEhlaWdodCIsImhlaWdodCIsIl9yZWYiLCJ2aXN1YWxWaWV3cG9ydCIsImFkZFZpc3VhbE9mZnNldHMiLCJ4IiwibGVmdCIsIm9mZnNldExlZnQiLCJ5IiwidG9wIiwib2Zmc2V0VG9wIiwicmlnaHQiLCJib3R0b20iLCJnZXRXaW5kb3dTY3JvbGwiLCJ3aW4iLCJzY3JvbGxMZWZ0IiwicGFnZVhPZmZzZXQiLCJzY3JvbGxUb3AiLCJwYWdlWU9mZnNldCIsImdldEhUTUxFbGVtZW50U2Nyb2xsIiwiZ2V0Tm9kZVNjcm9sbCIsImdldE5vZGVOYW1lIiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImdldERvY3VtZW50RWxlbWVudCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0V2luZG93U2Nyb2xsQmFyWCIsImdldENvbXB1dGVkU3R5bGUiLCJpc1Njcm9sbFBhcmVudCIsIl9nZXRDb21wdXRlZFN0eWxlIiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJpc0VsZW1lbnRTY2FsZWQiLCJyZWN0IiwiZ2V0Q29tcG9zaXRlUmVjdCIsImVsZW1lbnRPclZpcnR1YWxFbGVtZW50Iiwib2Zmc2V0UGFyZW50IiwiaXNGaXhlZCIsImlzT2Zmc2V0UGFyZW50QW5FbGVtZW50Iiwib2Zmc2V0UGFyZW50SXNTY2FsZWQiLCJzY3JvbGwiLCJvZmZzZXRzIiwiY2xpZW50TGVmdCIsImNsaWVudFRvcCIsImdldExheW91dFJlY3QiLCJhYnMiLCJnZXRQYXJlbnROb2RlIiwiYXNzaWduZWRTbG90IiwicGFyZW50Tm9kZSIsImhvc3QiLCJnZXRTY3JvbGxQYXJlbnQiLCJpbmRleE9mIiwiYm9keSIsImxpc3RTY3JvbGxQYXJlbnRzIiwibGlzdCIsIl9lbGVtZW50JG93bmVyRG9jdW1lbiIsInNjcm9sbFBhcmVudCIsImlzQm9keSIsInRhcmdldCIsImNvbmNhdCIsInVwZGF0ZWRMaXN0IiwiaXNUYWJsZUVsZW1lbnQiLCJnZXRUcnVlT2Zmc2V0UGFyZW50IiwicG9zaXRpb24iLCJnZXRDb250YWluaW5nQmxvY2siLCJpc0ZpcmVmb3giLCJpc0lFIiwiZWxlbWVudENzcyIsImN1cnJlbnROb2RlIiwiY3NzIiwidHJhbnNmb3JtIiwicGVyc3BlY3RpdmUiLCJjb250YWluIiwid2lsbENoYW5nZSIsImZpbHRlciIsImdldE9mZnNldFBhcmVudCIsImF1dG8iLCJiYXNlUGxhY2VtZW50cyIsInN0YXJ0IiwiZW5kIiwiY2xpcHBpbmdQYXJlbnRzIiwidmlld3BvcnQiLCJwb3BwZXIiLCJyZWZlcmVuY2UiLCJ2YXJpYXRpb25QbGFjZW1lbnRzIiwicmVkdWNlIiwiYWNjIiwicGxhY2VtZW50IiwicGxhY2VtZW50cyIsImJlZm9yZVJlYWQiLCJyZWFkIiwiYWZ0ZXJSZWFkIiwiYmVmb3JlTWFpbiIsIm1haW4iLCJhZnRlck1haW4iLCJiZWZvcmVXcml0ZSIsIndyaXRlIiwiYWZ0ZXJXcml0ZSIsIm1vZGlmaWVyUGhhc2VzIiwib3JkZXIiLCJtb2RpZmllcnMiLCJNYXAiLCJ2aXNpdGVkIiwiU2V0IiwicmVzdWx0IiwiZm9yRWFjaCIsIm1vZGlmaWVyIiwic2V0IiwibmFtZSIsInNvcnQiLCJhZGQiLCJyZXF1aXJlcyIsInJlcXVpcmVzSWZFeGlzdHMiLCJkZXAiLCJoYXMiLCJkZXBNb2RpZmllciIsImdldCIsInB1c2giLCJvcmRlck1vZGlmaWVycyIsIm9yZGVyZWRNb2RpZmllcnMiLCJwaGFzZSIsImRlYm91bmNlIiwiZm4iLCJwZW5kaW5nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwidW5kZWZpbmVkIiwibWVyZ2VCeU5hbWUiLCJtZXJnZWQiLCJjdXJyZW50IiwiZXhpc3RpbmciLCJhc3NpZ24iLCJvcHRpb25zIiwiZGF0YSIsImtleXMiLCJrZXkiLCJnZXRWaWV3cG9ydFJlY3QiLCJzdHJhdGVneSIsImh0bWwiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImxheW91dFZpZXdwb3J0IiwiZ2V0RG9jdW1lbnRSZWN0Iiwid2luU2Nyb2xsIiwic2Nyb2xsV2lkdGgiLCJzY3JvbGxIZWlnaHQiLCJkaXJlY3Rpb24iLCJjb250YWlucyIsInBhcmVudCIsImNoaWxkIiwicm9vdE5vZGUiLCJnZXRSb290Tm9kZSIsIm5leHQiLCJpc1NhbWVOb2RlIiwicmVjdFRvQ2xpZW50UmVjdCIsImdldElubmVyQm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUiLCJjbGlwcGluZ1BhcmVudCIsImdldENsaXBwaW5nUGFyZW50cyIsImNhbkVzY2FwZUNsaXBwaW5nIiwiY2xpcHBlckVsZW1lbnQiLCJnZXRDbGlwcGluZ1JlY3QiLCJib3VuZGFyeSIsInJvb3RCb3VuZGFyeSIsIm1haW5DbGlwcGluZ1BhcmVudHMiLCJmaXJzdENsaXBwaW5nUGFyZW50IiwiY2xpcHBpbmdSZWN0IiwiYWNjUmVjdCIsImdldEJhc2VQbGFjZW1lbnQiLCJzcGxpdCIsImdldFZhcmlhdGlvbiIsImdldE1haW5BeGlzRnJvbVBsYWNlbWVudCIsImNvbXB1dGVPZmZzZXRzIiwiYmFzZVBsYWNlbWVudCIsInZhcmlhdGlvbiIsImNvbW1vblgiLCJjb21tb25ZIiwibWFpbkF4aXMiLCJsZW4iLCJnZXRGcmVzaFNpZGVPYmplY3QiLCJtZXJnZVBhZGRpbmdPYmplY3QiLCJwYWRkaW5nT2JqZWN0IiwiZXhwYW5kVG9IYXNoTWFwIiwiaGFzaE1hcCIsImRldGVjdE92ZXJmbG93Iiwic3RhdGUiLCJfb3B0aW9ucyIsIl9vcHRpb25zJHBsYWNlbWVudCIsIl9vcHRpb25zJHN0cmF0ZWd5IiwiX29wdGlvbnMkYm91bmRhcnkiLCJfb3B0aW9ucyRyb290Qm91bmRhcnkiLCJfb3B0aW9ucyRlbGVtZW50Q29udGUiLCJlbGVtZW50Q29udGV4dCIsIl9vcHRpb25zJGFsdEJvdW5kYXJ5IiwiYWx0Qm91bmRhcnkiLCJfb3B0aW9ucyRwYWRkaW5nIiwicGFkZGluZyIsImFsdENvbnRleHQiLCJwb3BwZXJSZWN0IiwicmVjdHMiLCJlbGVtZW50cyIsImNsaXBwaW5nQ2xpZW50UmVjdCIsImNvbnRleHRFbGVtZW50IiwicmVmZXJlbmNlQ2xpZW50UmVjdCIsInBvcHBlck9mZnNldHMiLCJwb3BwZXJDbGllbnRSZWN0IiwiZWxlbWVudENsaWVudFJlY3QiLCJvdmVyZmxvd09mZnNldHMiLCJvZmZzZXREYXRhIiwibW9kaWZpZXJzRGF0YSIsIm9mZnNldCIsIm11bHRpcGx5IiwiYXhpcyIsIkRFRkFVTFRfT1BUSU9OUyIsImFyZVZhbGlkRWxlbWVudHMiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIl9rZXkiLCJzb21lIiwicG9wcGVyR2VuZXJhdG9yIiwiZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zIiwiX2dlbmVyYXRvck9wdGlvbnMkZGVmIiwiZGVmYXVsdE1vZGlmaWVycyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZjIiLCJkZWZhdWx0T3B0aW9ucyIsImNyZWF0ZVBvcHBlciIsImF0dHJpYnV0ZXMiLCJzdHlsZXMiLCJlZmZlY3RDbGVhbnVwRm5zIiwiaXNEZXN0cm95ZWQiLCJpbnN0YW5jZSIsInNldE9wdGlvbnMiLCJzZXRPcHRpb25zQWN0aW9uIiwiY2xlYW51cE1vZGlmaWVyRWZmZWN0cyIsInNjcm9sbFBhcmVudHMiLCJtIiwiZW5hYmxlZCIsInJ1bk1vZGlmaWVyRWZmZWN0cyIsInVwZGF0ZSIsImZvcmNlVXBkYXRlIiwiX3N0YXRlJGVsZW1lbnRzIiwicmVzZXQiLCJpbmRleCIsIl9zdGF0ZSRvcmRlcmVkTW9kaWZpZSIsIl9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIiLCJkZXN0cm95Iiwib25GaXJzdFVwZGF0ZSIsIl9yZWYkb3B0aW9ucyIsImVmZmVjdCIsImNsZWFudXBGbiIsIm5vb3BGbiIsInBhc3NpdmUiLCJlZmZlY3QkMiIsIl9vcHRpb25zJHNjcm9sbCIsIl9vcHRpb25zJHJlc2l6ZSIsInJlc2l6ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZXZlbnRMaXN0ZW5lcnMiLCJwb3BwZXJPZmZzZXRzJDEiLCJ1bnNldFNpZGVzIiwicm91bmRPZmZzZXRzQnlEUFIiLCJkcHIiLCJkZXZpY2VQaXhlbFJhdGlvIiwibWFwVG9TdHlsZXMiLCJfcmVmMiIsIl9PYmplY3QkYXNzaWduMiIsImdwdUFjY2VsZXJhdGlvbiIsImFkYXB0aXZlIiwicm91bmRPZmZzZXRzIiwiX29mZnNldHMkeCIsIl9vZmZzZXRzJHkiLCJfcmVmMyIsImhhc1giLCJoYXNPd25Qcm9wZXJ0eSIsImhhc1kiLCJzaWRlWCIsInNpZGVZIiwiaGVpZ2h0UHJvcCIsIndpZHRoUHJvcCIsIm9mZnNldFkiLCJvZmZzZXRYIiwiY29tbW9uU3R5bGVzIiwiX3JlZjQiLCJfT2JqZWN0JGFzc2lnbiIsImNvbXB1dGVTdHlsZXMiLCJfcmVmNSIsIl9vcHRpb25zJGdwdUFjY2VsZXJhdCIsIl9vcHRpb25zJGFkYXB0aXZlIiwiX29wdGlvbnMkcm91bmRPZmZzZXRzIiwiYXJyb3ciLCJjb21wdXRlU3R5bGVzJDEiLCJhcHBseVN0eWxlcyIsInN0eWxlIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiZWZmZWN0JDEiLCJpbml0aWFsU3R5bGVzIiwibWFyZ2luIiwic3R5bGVQcm9wZXJ0aWVzIiwicHJvcGVydHkiLCJhdHRyaWJ1dGUiLCJhcHBseVN0eWxlcyQxIiwiZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkiLCJpbnZlcnREaXN0YW5jZSIsInNraWRkaW5nIiwiZGlzdGFuY2UiLCJfb3B0aW9ucyRvZmZzZXQiLCJfZGF0YSRzdGF0ZSRwbGFjZW1lbnQiLCJvZmZzZXQkMSIsImhhc2gkMSIsImdldE9wcG9zaXRlUGxhY2VtZW50IiwicmVwbGFjZSIsIm1hdGNoZWQiLCJoYXNoIiwiZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQiLCJjb21wdXRlQXV0b1BsYWNlbWVudCIsImZsaXBWYXJpYXRpb25zIiwiX29wdGlvbnMkYWxsb3dlZEF1dG9QIiwiYWxsb3dlZEF1dG9QbGFjZW1lbnRzIiwicGxhY2VtZW50cyQxIiwiYWxsb3dlZFBsYWNlbWVudHMiLCJvdmVyZmxvd3MiLCJhIiwiYiIsImdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzIiwib3Bwb3NpdGVQbGFjZW1lbnQiLCJmbGlwIiwiX3NraXAiLCJfb3B0aW9ucyRtYWluQXhpcyIsImNoZWNrTWFpbkF4aXMiLCJfb3B0aW9ucyRhbHRBeGlzIiwiYWx0QXhpcyIsImNoZWNrQWx0QXhpcyIsInNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyIsImZhbGxiYWNrUGxhY2VtZW50cyIsIl9vcHRpb25zJGZsaXBWYXJpYXRpbyIsInByZWZlcnJlZFBsYWNlbWVudCIsImlzQmFzZVBsYWNlbWVudCIsInJlZmVyZW5jZVJlY3QiLCJjaGVja3NNYXAiLCJtYWtlRmFsbGJhY2tDaGVja3MiLCJmaXJzdEZpdHRpbmdQbGFjZW1lbnQiLCJpIiwiX2Jhc2VQbGFjZW1lbnQiLCJpc1N0YXJ0VmFyaWF0aW9uIiwiaXNWZXJ0aWNhbCIsIm1haW5WYXJpYXRpb25TaWRlIiwiYWx0VmFyaWF0aW9uU2lkZSIsImNoZWNrcyIsImV2ZXJ5IiwiY2hlY2siLCJudW1iZXJPZkNoZWNrcyIsIl9sb29wIiwiX2kiLCJmaXR0aW5nUGxhY2VtZW50IiwiZmluZCIsInNsaWNlIiwiX3JldCIsImZsaXAkMSIsImdldEFsdEF4aXMiLCJ3aXRoaW4iLCJtaW4kMSIsIm1heCQxIiwid2l0aGluTWF4Q2xhbXAiLCJ2IiwicHJldmVudE92ZXJmbG93IiwiX29wdGlvbnMkdGV0aGVyIiwidGV0aGVyIiwiX29wdGlvbnMkdGV0aGVyT2Zmc2V0IiwidGV0aGVyT2Zmc2V0IiwidGV0aGVyT2Zmc2V0VmFsdWUiLCJub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUiLCJvZmZzZXRNb2RpZmllclN0YXRlIiwiX29mZnNldE1vZGlmaWVyU3RhdGUkIiwibWFpblNpZGUiLCJhbHRTaWRlIiwiYWRkaXRpdmUiLCJtaW5MZW4iLCJtYXhMZW4iLCJhcnJvd0VsZW1lbnQiLCJhcnJvd1JlY3QiLCJhcnJvd1BhZGRpbmdPYmplY3QiLCJhcnJvd1BhZGRpbmdNaW4iLCJhcnJvd1BhZGRpbmdNYXgiLCJhcnJvd0xlbiIsIm1pbk9mZnNldCIsIm1heE9mZnNldCIsImFycm93T2Zmc2V0UGFyZW50IiwiY2xpZW50T2Zmc2V0Iiwib2Zmc2V0TW9kaWZpZXJWYWx1ZSIsInRldGhlck1pbiIsInRldGhlck1heCIsInByZXZlbnRlZE9mZnNldCIsIl9vZmZzZXRNb2RpZmllclN0YXRlJDIiLCJfbWFpblNpZGUiLCJfYWx0U2lkZSIsIl9vZmZzZXQiLCJfbWluIiwiX21heCIsImlzT3JpZ2luU2lkZSIsIl9vZmZzZXRNb2RpZmllclZhbHVlIiwiX3RldGhlck1pbiIsIl90ZXRoZXJNYXgiLCJfcHJldmVudGVkT2Zmc2V0IiwicHJldmVudE92ZXJmbG93JDEiLCJ0b1BhZGRpbmdPYmplY3QiLCJfc3RhdGUkbW9kaWZpZXJzRGF0YSQiLCJtaW5Qcm9wIiwibWF4UHJvcCIsImVuZERpZmYiLCJzdGFydERpZmYiLCJjbGllbnRTaXplIiwiY2VudGVyVG9SZWZlcmVuY2UiLCJjZW50ZXIiLCJheGlzUHJvcCIsImNlbnRlck9mZnNldCIsIl9vcHRpb25zJGVsZW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiYXJyb3ckMSIsImdldFNpZGVPZmZzZXRzIiwicHJldmVudGVkT2Zmc2V0cyIsImlzQW55U2lkZUZ1bGx5Q2xpcHBlZCIsInNpZGUiLCJoaWRlIiwicmVmZXJlbmNlT3ZlcmZsb3ciLCJwb3BwZXJBbHRPdmVyZmxvdyIsInJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyIsInBvcHBlckVzY2FwZU9mZnNldHMiLCJpc1JlZmVyZW5jZUhpZGRlbiIsImhhc1BvcHBlckVzY2FwZWQiLCJoaWRlJDEiLCJkZWZhdWx0TW9kaWZpZXJzJDEiLCJjcmVhdGVQb3BwZXIkMSIsImNyZWF0ZVBvcHBlckxpdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@popperjs/core/dist/cjs/popper.js\n");

/***/ })

};
;